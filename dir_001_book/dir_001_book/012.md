---
marp: false
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 12: Exception Handling and Text I/O

---

## 12.1. Introduction:

---

---

**Slide Title: Introduction to Exception Handling**

#### **Key Points:**

- **What are Exceptions?**

  - Runtime errors that disrupt normal program flow.
  - Examples: Dividing by zero, invalid input, out-of-bounds access.

- **Exception Handling:**

  - Helps manage runtime errors without crashing the program.
  - Allows for graceful error recovery.

- **Java Exception Model:**

  - Java throws exceptions as objects.
  - Unhandled exceptions terminate the program.
  - Can be caught and managed using `try-catch`.

- **Example of an Exception:**

  ```java
  int[] numbers = {1, 2, 3};
  System.out.println(numbers[5]); // ArrayIndexOutOfBoundsException
  ```

- **Why Learn Exception Handling?**
  - Improves program stability.
  - Makes debugging easier.
  - Separates error handling from normal logic.

**Visual Idea:**

- A diagram showing program flow with and without exception handling.
- Example of a `try-catch` block in Java.

---

Would you like me to format this into PowerPoint slides or add more details?

---

## 12.2. Exception-Handling Overview

---

\*\*

---

#### **Slide Title: Exception-Handling Overview**

#### **Key Concepts**

- **What is Exception Handling?**

  - Mechanism to detect, catch, and handle runtime errors.
  - Prevents program crashes and enables error recovery.

- **How Does Exception Handling Work?**

  - **Throwing an Exception:** Error is detected, and an exception is raised.
  - **Catching an Exception:** The program handles the exception to avoid abrupt termination.

- **Basic `try-catch` Structure:**

  ```java
  try {
      int result = 10 / 0; // Error: Division by zero
  } catch (ArithmeticException e) {
      System.out.println("Cannot divide by zero.");
  }
  ```

- **Flow of Exception Handling**

  1. Program encounters an error.
  2. An exception is thrown.
  3. The exception is caught in a `catch` block.
  4. Program continues execution safely.

- **Advantages of Exception Handling**  
  ‚úÖ Improves program reliability.  
  ‚úÖ Separates normal logic from error-handling code.  
  ‚úÖ Provides meaningful error messages.

#### **Visual Idea:**

- A flowchart showing exception propagation and handling.
- Diagram of `try`, `catch`, and `finally` blocks.

---

Would you like me to format this into a PowerPoint slide, or do you need additional details?

---

## 12.3. Exception Types

---

\*\* from your document. I will include key points and visuals to make it engaging.

---

#### **Slide 1: Title Slide**

**Title:** Exception Types in Java  
**Subtitle:** Understanding Errors, Exceptions, and Runtime Exceptions

---

#### **Slide 2: Introduction to Exceptions**

- Exceptions are objects in Java, defined using classes.
- The root class for all exceptions is `java.lang.Throwable`.
- Exceptions help handle runtime errors gracefully.

---

#### **Slide 3: Hierarchy of Exceptions**

(Include a visual of the exception hierarchy from Figure 12.1)

- `Throwable` (Root class)
  - `Error` (System errors, fatal)
  - `Exception` (Can be handled)
    - `Checked Exceptions` (Must be handled in code)
    - `Unchecked Exceptions` (Runtime exceptions, programming errors)

---

#### **Slide 4: System Errors (`Error` Class)**

- Thrown by the JVM, usually fatal.
- Examples:
  - `LinkageError` (Class dependency issues)
  - `VirtualMachineError` (JVM resource exhaustion)
- **Cannot** be handled by the program.

---

#### **Slide 5: Exceptions (`Exception` Class)**

- Caused by external factors or programming logic.
- **Must** be handled using `try-catch` or declared with `throws`.
- Examples:
  - `ClassNotFoundException` (Missing class file)
  - `IOException` (File read/write issues)

---

#### **Slide 6: Runtime Exceptions (`RuntimeException` Class)**

- Usually due to bad programming logic.
- **Unchecked exceptions** (not required to be caught).
- Examples:
  - `ArithmeticException` (Divide by zero)
  - `NullPointerException` (Accessing an object via `null`)
  - `IndexOutOfBoundsException` (Invalid array index)

---

#### **Slide 7: Checked vs. Unchecked Exceptions**

| **Type**      | **Examples**                                  | **Handling Required?**  |
| ------------- | --------------------------------------------- | ----------------------- |
| **Checked**   | `IOException`, `SQLException`                 | ‚úÖ Yes                  |
| **Unchecked** | `NullPointerException`, `ArithmeticException` | ‚ùå No (but recommended) |

---

#### **Slide 8: Why Exception Handling?**

- Prevents abrupt program termination.
- Allows error recovery and debugging.
- Makes code more readable and maintainable.

---

#### **Slide 9: Summary**

- Exceptions are classified into **Errors, Checked Exceptions, and Unchecked Exceptions**.
- **Checked exceptions must be handled** explicitly.
- **Unchecked exceptions indicate programming mistakes**.

---

#### **Slide 10: Q&A**

"Any questions?"

Would you like me to generate the slides in PowerPoint format, or do you need additional edits? üòä

---

## 12.4. Declaring, Throwing, and Catching Exceptions

---

\*\* from your document. This will include key concepts, visuals, and examples to make it engaging.

---

#### **Slide 1: Title Slide**

**Title:** Declaring, Throwing, and Catching Exceptions  
**Subtitle:** Handling Errors in Java Programs

---

#### **Slide 2: Introduction**

- Java‚Äôs exception-handling model is based on three key actions:
  1. **Declaring** exceptions
  2. **Throwing** exceptions
  3. **Catching** exceptions
- Helps in error recovery and program stability.

---

#### **Slide 3: Declaring Exceptions**

- Methods must **declare checked exceptions** using the `throws` keyword.
- Syntax:
  ```java
  public void myMethod() throws IOException {
      // Method code
  }
  ```
- A method can declare **multiple exceptions** using commas.
- **Unchecked exceptions (RuntimeException & subclasses) do not need to be declared.**

---

#### **Slide 4: Throwing Exceptions**

- Use the `throw` keyword to generate an exception.
- Syntax:
  ```java
  throw new Exception("Error message");
  ```
- Example: Throwing `IllegalArgumentException`:
  ```java
  public void setAge(int age) {
      if (age < 0) {
          throw new IllegalArgumentException("Age cannot be negative");
      }
  }
  ```

---

#### **Slide 5: Catching Exceptions**

- **Handle exceptions** using `try-catch` blocks.
- Syntax:
  ```java
  try {
      // Code that might cause an exception
  } catch (ExceptionType ex) {
      // Handle the exception
  }
  ```
- Example:
  ```java
  try {
      int result = 10 / 0; // This will cause ArithmeticException
  } catch (ArithmeticException ex) {
      System.out.println("Cannot divide by zero.");
  }
  ```

---

#### **Slide 6: Exception Propagation**

- **If an exception is not caught**, it propagates up the call stack.
- Example:

  ```java
  public void method1() throws Exception {
      method2();
  }

  public void method2() throws Exception {
      throw new Exception("Error in method2");
  }
  ```

- **If no method handles it, the program crashes.**

---

#### **Slide 7: Multiple Catch Blocks**

- You can **handle different exceptions separately**.
- Example:
  ```java
  try {
      int[] arr = new int[5];
      System.out.println(arr[10]); // Out of bounds
  } catch (ArithmeticException ex) {
      System.out.println("Arithmetic error!");
  } catch (ArrayIndexOutOfBoundsException ex) {
      System.out.println("Index out of bounds!");
  }
  ```
- **Always catch specific exceptions before generic ones (`Exception`).**

---

#### **Slide 8: The `finally` Block**

- **Executes always, whether an exception occurs or not.**
- Used for resource cleanup.
- Example:
  ```java
  try {
      // Open file
  } catch (IOException ex) {
      System.out.println("Error!");
  } finally {
      // Close file
  }
  ```

---

#### **Slide 9: Summary**

- **Declaring Exceptions:** Use `throws` for checked exceptions.
- **Throwing Exceptions:** Use `throw new ExceptionType("message")`.
- **Catching Exceptions:** Use `try-catch`, and handle different exceptions separately.
- **Finally Block:** Always executes, used for cleanup.

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.5. The `finally` Clause

---

\*\* from your document. This will include key points, explanations, and examples to make the concept clear.

---

#### **Slide 1: Title Slide**

**Title:** The `finally` Clause  
**Subtitle:** Ensuring Code Execution in Java Exception Handling

---

#### **Slide 2: Introduction**

- The `finally` block **always executes**, whether an exception occurs or not.
- Used for **resource cleanup**, such as closing files, releasing memory, or disconnecting from databases.

---

#### **Slide 3: Why Use `finally`?**

- Ensures **important cleanup code** runs even if an exception occurs.
- Used in **file handling, database connections, and network operations**.
- Prevents **resource leaks**.

---

#### **Slide 4: Syntax of `finally`**

```java
try {
    // Code that may throw an exception
} catch (ExceptionType ex) {
    // Handle the exception
} finally {
    // Code that will always execute
}
```

- The `finally` block **executes regardless of exception occurrence**.

---

#### **Slide 5: Example of `finally` Usage**

```java
public class FinallyExample {
    public static void main(String[] args) {
        try {
            int result = 10 / 0; // This will throw an exception
        } catch (ArithmeticException ex) {
            System.out.println("Exception caught: " + ex.getMessage());
        } finally {
            System.out.println("This code runs no matter what.");
        }
    }
}
```

**Output:**

```
Exception caught: / by zero
This code runs no matter what.
```

---

#### **Slide 6: `finally` Without a `catch` Block**

- `finally` can be used **without** a `catch` block.

```java
try {
    System.out.println("Try block executed.");
} finally {
    System.out.println("Finally block executed.");
}
```

**Output:**

```
Try block executed.
Finally block executed.
```

---

#### **Slide 7: When `finally` Does Not Execute**

- The only scenarios where `finally` **may not execute**:
  - If `System.exit(0)` is called inside `try` or `catch`.
  - If the program **crashes** (e.g., infinite loop, power failure).

Example:

```java
try {
    System.exit(0);
} finally {
    System.out.println("This will NOT execute.");
}
```

---

#### **Slide 8: Common Use Cases of `finally`**

- **Closing file resources**
  ```java
  try {
      FileReader file = new FileReader("test.txt");
  } catch (IOException ex) {
      System.out.println("File not found.");
  } finally {
      file.close(); // Ensures the file is closed
  }
  ```
- **Releasing database connections**
- **Cleaning up memory (e.g., closing scanners)**

---

#### **Slide 9: Summary**

‚úÖ The `finally` block **always executes**, ensuring resource cleanup.  
‚úÖ Used for **closing files, database connections, and network resources**.  
‚úÖ Can be used **without a `catch` block**.  
‚úÖ Will **not execute** only if `System.exit(0)` is called.

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.6. When to Use Exceptions

---

\*\* from your document. This will include key points, explanations, and examples to make the concept clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** When to Use Exceptions  
**Subtitle:** Best Practices for Exception Handling in Java

---

#### **Slide 2: Introduction**

- **Exceptions** should be used when a method **cannot complete its task** in a normal way.
- **Goal:** Separate error-handling logic from normal program logic.
- **Exception handling makes programs more readable and maintainable.**

---

#### **Slide 3: When to Use Exceptions?**

‚úÖ **For unexpected or serious errors**  
‚úÖ **When an error needs to be handled by the caller**  
‚úÖ **To separate error detection from error handling**

‚ùå **Do NOT use exceptions for simple flow control** (e.g., checking if a value is null).

---

#### **Slide 4: Bad Example ‚Äì Using Exceptions for Control Flow**

‚ùå **Inefficient way to check if a value is numeric:**

```java
public static boolean isNumeric(String token) {
    try {
        Double.parseDouble(token);
        return true;
    } catch (NumberFormatException ex) {
        return false;
    }
}
```

**Problem:** Exceptions are expensive in terms of performance.

---

#### **Slide 5: Good Example ‚Äì Using Normal Logic Instead**

‚úÖ **Better way to check if a value is numeric:**

```java
public static boolean isNumeric(String token) {
    for (char c : token.toCharArray()) {
        if (!Character.isDigit(c)) {
            return false;
        }
    }
    return true;
}
```

- **Uses simple logic instead of exceptions.**
- **Improves performance.**

---

#### **Slide 6: When NOT to Use Exceptions?**

‚ùå **For handling predictable conditions:**

- Checking if a file exists
- Validating user input
- Loop termination

‚úÖ **Use if-else statements instead.**

Example (Better Approach):

```java
if (file.exists()) {
    System.out.println("File found!");
} else {
    System.out.println("File not found.");
}
```

---

#### **Slide 7: Correct Use of Exceptions**

‚úÖ **For serious or unpredictable errors:**

- **File not found:**
  ```java
  try {
      FileReader file = new FileReader("data.txt");
  } catch (FileNotFoundException ex) {
      System.out.println("File not found!");
  }
  ```
- **Invalid user input:**
  ```java
  try {
      int age = Integer.parseInt(input);
  } catch (NumberFormatException ex) {
      System.out.println("Invalid number format.");
  }
  ```

---

#### **Slide 8: Key Takeaways**

‚úÖ **Use exceptions for unexpected or serious errors.**  
‚úÖ **Do NOT use exceptions for normal control flow.**  
‚úÖ **Prefer if-else statements for simple conditions.**  
‚úÖ **Use exception handling to improve code readability.**

---

#### **Slide 9: Summary**

- **Exceptions should not replace regular logic checks.**
- **Handle predictable errors with if-else conditions.**
- **Use exceptions only when absolutely necessary.**

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.7. Rethrowing Exceptions

---

\*\* from your document. This will include key points, explanations, and examples to make the concept clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** Rethrowing Exceptions  
**Subtitle:** Passing Exceptions to the Caller in Java

---

#### **Slide 2: Introduction**

- **What is Rethrowing an Exception?**
  - An exception is **caught** in a method but **not fully handled**, so it is thrown again to be handled elsewhere.
- **Why rethrow an exception?**
  - Allows the caller of a method to handle the exception.
  - Maintains the original exception details.

---

#### **Slide 3: Syntax for Rethrowing Exceptions**

```java
try {
    // Code that may throw an exception
} catch (ExceptionType ex) {
    // Perform some operations before rethrowing
    throw ex;
}
```

- **The `throw` statement sends the exception back to the caller.**

---

#### **Slide 4: Example ‚Äì Rethrowing an Exception**

```java
public class RethrowExample {
    public static void method1() throws Exception {
        try {
            int result = 10 / 0; // Will cause ArithmeticException
        } catch (ArithmeticException ex) {
            System.out.println("Exception caught in method1.");
            throw ex; // Rethrow the exception
        }
    }

    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception ex) {
            System.out.println("Exception handled in main.");
        }
    }
}
```

**Output:**

```
Exception caught in method1.
Exception handled in main.
```

---

#### **Slide 5: When to Rethrow an Exception?**

‚úÖ **If the method cannot fully handle the exception.**  
‚úÖ **When the exception should be handled by a higher-level method.**  
‚úÖ **When you need to log or modify the exception before passing it.**

---

#### **Slide 6: Preserving Exception Information**

- Rethrowing an exception **loses** stack trace information.
- Use `throw ex;` to rethrow **without modification**.
- Use `throw new Exception("New message", ex);` to **wrap** the original exception.

Example:

```java
try {
    method1();
} catch (Exception ex) {
    throw new Exception("New info", ex); // Chained exception
}
```

---

#### **Slide 7: Example ‚Äì Rethrowing with Additional Information**

```java
public class ChainedExceptionExample {
    public static void method1() throws Exception {
        try {
            throw new NullPointerException("Null reference");
        } catch (NullPointerException ex) {
            throw new Exception("Error in method1", ex);
        }
    }

    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception ex) {
            ex.printStackTrace(); // Shows original exception cause
        }
    }
}
```

**Output:**

```
java.lang.Exception: Error in method1
Caused by: java.lang.NullPointerException: Null reference
```

---

#### **Slide 8: Key Takeaways**

‚úÖ **Rethrowing an exception allows a higher-level method to handle it.**  
‚úÖ **Use `throw ex;` to rethrow without modifying the original exception.**  
‚úÖ **Use `throw new Exception("Message", ex);` to add context.**  
‚úÖ **Maintains clean and readable error handling.**

---

#### **Slide 9: Summary**

- **Rethrowing is useful when an exception cannot be fully handled in a method.**
- **Preserve the original exception details for debugging.**
- **Use chained exceptions when adding more context.**

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.8. Chained Exceptions

---

\*\* from your document. This will include key concepts, explanations, and examples to make the topic clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** Chained Exceptions  
**Subtitle:** Linking Exceptions for Better Debugging

---

#### **Slide 2: Introduction**

- **What are Chained Exceptions?**
  - When a new exception is thrown while handling an existing exception.
  - Allows preserving the **original cause** of an error.
- **Why use Chained Exceptions?**  
  ‚úÖ Helps track the root cause of an error.  
  ‚úÖ Provides more detailed debugging information.

---

#### **Slide 3: Syntax for Chained Exceptions**

```java
throw new Exception("New exception message", originalException);
```

- The second parameter (`originalException`) **stores the cause of the new exception**.

---

#### **Slide 4: Example ‚Äì Chaining Exceptions**

```java
public class ChainedExceptionExample {
    public static void method1() throws Exception {
        try {
            throw new NullPointerException("Null reference error");
        } catch (NullPointerException ex) {
            throw new Exception("Error in method1", ex); // Chain exception
        }
    }

    public static void main(String[] args) {
        try {
            method1();
        } catch (Exception ex) {
            ex.printStackTrace(); // Displays chained exceptions
        }
    }
}
```

**Output:**

```
java.lang.Exception: Error in method1
Caused by: java.lang.NullPointerException: Null reference error
```

---

#### **Slide 5: Using `getCause()` to Retrieve Exception Cause**

```java
try {
    method1();
} catch (Exception ex) {
    System.out.println("Main exception: " + ex.getMessage());
    System.out.println("Caused by: " + ex.getCause());
}
```

- The `getCause()` method **retrieves the original exception** that caused the current one.

---

#### **Slide 6: When to Use Chained Exceptions?**

‚úÖ When handling **low-level** errors that affect higher-level logic.  
‚úÖ When adding **more context** to an error.  
‚úÖ When reporting **multiple related exceptions**.

---

#### **Slide 7: Example ‚Äì Adding More Context**

```java
public class CustomChainedException {
    public static void validateAge(int age) throws Exception {
        if (age < 0) {
            throw new IllegalArgumentException("Negative age provided");
        }
    }

    public static void main(String[] args) {
        try {
            validateAge(-5);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException("Invalid input detected", ex);
        }
    }
}
```

- **Enhances error messages** while keeping the original cause.

---

#### **Slide 8: Key Takeaways**

‚úÖ **Chained exceptions preserve the root cause of an error.**  
‚úÖ **Use `throw new Exception("message", cause);` to link exceptions.**  
‚úÖ **Use `getCause()` to retrieve original exceptions.**  
‚úÖ **Helpful for debugging and providing better error messages.**

---

#### **Slide 9: Summary**

- Chained exceptions help track the **true cause of an error**.
- Use them when one exception leads to another.
- Preserve original errors to **improve debugging**.

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.9. Defining Custom Exception Classes

---

\*\* from your document. This will include key concepts, explanations, and examples to make the topic clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** Defining Custom Exception Classes  
**Subtitle:** Creating User-Defined Exceptions in Java

---

#### **Slide 2: Introduction**

- **What is a Custom Exception?**
  - A user-defined exception that extends Java‚Äôs `Exception` class.
  - Used when predefined exceptions do not fully describe an error scenario.
- **Why create custom exceptions?**  
  ‚úÖ Provides more meaningful error messages.  
  ‚úÖ Makes error handling more specific.  
  ‚úÖ Helps organize application-specific errors.

---

#### **Slide 3: How to Create a Custom Exception**

- **Extend `Exception` or `RuntimeException`**
- **Define constructors**
- **Provide useful methods if needed**

---

#### **Slide 4: Example ‚Äì Creating a Custom Exception**

```java
// Step 1: Define a custom exception class
public class InvalidRadiusException extends Exception {
    private double radius;

    public InvalidRadiusException(double radius) {
        super("Invalid radius: " + radius);
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }
}
```

- **Extends `Exception`** (making it a checked exception).
- **Stores additional information (`radius`)**.
- **Provides a constructor to set a custom message**.

---

#### **Slide 5: Using the Custom Exception in a Class**

```java
public class Circle {
    private double radius;

    public Circle(double radius) throws InvalidRadiusException {
        setRadius(radius);
    }

    public void setRadius(double radius) throws InvalidRadiusException {
        if (radius < 0) {
            throw new InvalidRadiusException(radius);
        }
        this.radius = radius;
    }
}
```

- The `setRadius()` method **throws `InvalidRadiusException`** if the radius is negative.

---

#### **Slide 6: Handling a Custom Exception**

```java
public class TestCustomException {
    public static void main(String[] args) {
        try {
            Circle c = new Circle(-5); // Invalid radius
        } catch (InvalidRadiusException ex) {
            System.out.println("Exception: " + ex.getMessage());
        }
    }
}
```

**Output:**

```
Exception: Invalid radius: -5.0
```

- The program **catches and handles the custom exception**.

---

#### **Slide 7: Checked vs. Unchecked Custom Exceptions**

| Exception Type | Extend Class       | Must be Handled? | Example                  |
| -------------- | ------------------ | ---------------- | ------------------------ |
| **Checked**    | `Exception`        | ‚úÖ Yes           | `InvalidRadiusException` |
| **Unchecked**  | `RuntimeException` | ‚ùå No            | `InvalidInputException`  |

‚úÖ Use **checked exceptions** when the caller **must handle** the error.  
‚úÖ Use **unchecked exceptions** when the error is **due to programming mistakes**.

---

#### **Slide 8: Example ‚Äì Unchecked Custom Exception**

```java
public class NegativeNumberException extends RuntimeException {
    public NegativeNumberException(String message) {
        super(message);
    }
}
```

- **Extends `RuntimeException`**, so it is an unchecked exception.

---

#### **Slide 9: When to Use Custom Exceptions?**

‚úÖ When built-in exceptions **do not describe the error well**.  
‚úÖ When you **want to pass additional information** with the error.  
‚úÖ When creating a **specific exception hierarchy for an application**.

---

#### **Slide 10: Summary**

- **Custom exceptions provide clearer, application-specific error messages.**
- **Extend `Exception` for checked exceptions, `RuntimeException` for unchecked ones.**
- **Use them when built-in exceptions are not specific enough.**

---

#### **Slide 11: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.10. The File Class

---

\*\* from your document. This will include key concepts, explanations, and examples to make the topic clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** The `File` Class  
**Subtitle:** Managing Files and Directories in Java

---

#### **Slide 2: Introduction**

- **What is the `File` class?**
  - A Java class for handling file and directory operations.
  - Part of the `java.io` package.
- **What can it do?**  
  ‚úÖ Check file properties (size, permissions, last modified, etc.).  
  ‚úÖ Create, delete, and rename files and directories.  
  ‚úÖ List files in a directory.

---

#### **Slide 3: Creating a `File` Object**

- The `File` class **represents** file and directory paths but does not handle file content.

```java
import java.io.File;

public class FileExample {
    public static void main(String[] args) {
        File myFile = new File("example.txt");
        System.out.println("File object created.");
    }
}
```

‚úÖ **Creates a `File` object** (does not create an actual file).

---

#### **Slide 4: Checking If a File Exists**

```java
File file = new File("example.txt");

if (file.exists()) {
    System.out.println("File exists.");
} else {
    System.out.println("File does not exist.");
}
```

- The `exists()` method **checks if the file is available**.

---

#### **Slide 5: File Properties & Methods**

| **Method**       | **Description**                  |
| ---------------- | -------------------------------- |
| `exists()`       | Checks if file/directory exists. |
| `canRead()`      | Checks if file is readable.      |
| `canWrite()`     | Checks if file is writable.      |
| `isFile()`       | Checks if path is a file.        |
| `isDirectory()`  | Checks if path is a directory.   |
| `length()`       | Returns file size (bytes).       |
| `lastModified()` | Returns last modified time.      |

---

#### **Slide 6: Example ‚Äì Checking File Properties**

```java
File file = new File("example.txt");

if (file.exists()) {
    System.out.println("File Name: " + file.getName());
    System.out.println("Absolute Path: " + file.getAbsolutePath());
    System.out.println("Size: " + file.length() + " bytes");
    System.out.println("Writable: " + file.canWrite());
    System.out.println("Readable: " + file.canRead());
}
```

‚úÖ **Retrieves file details** like name, path, size, and permissions.

---

#### **Slide 7: Creating and Deleting Files**

```java
try {
    File file = new File("newfile.txt");
    if (file.createNewFile()) {
        System.out.println("File created.");
    } else {
        System.out.println("File already exists.");
    }
} catch (IOException e) {
    System.out.println("An error occurred.");
}
```

‚úÖ **Creates a new file** using `createNewFile()`.  
‚úÖ **Handles errors** with `IOException`.

```java
if (file.delete()) {
    System.out.println("File deleted.");
}
```

‚úÖ **Deletes a file** with `delete()`.

---

#### **Slide 8: Working with Directories**

```java
File dir = new File("myDirectory");

// Creating a directory
if (dir.mkdir()) {
    System.out.println("Directory created.");
}

// Listing files in a directory
String[] files = dir.list();
for (String file : files) {
    System.out.println(file);
}
```

‚úÖ **Creates a directory using `mkdir()`.**  
‚úÖ **Lists files in a directory using `list()`.**

---

#### **Slide 9: Summary**

- The `File` class **manages file and directory paths** (but does not read/write data).
- Provides **methods to check file properties** (`exists()`, `length()`, `canRead()`).
- Allows **creating and deleting files and directories**.

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.11. File Input and Output

---

\*\* from your document. This will include key concepts, explanations, and examples to make the topic clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** File Input and Output  
**Subtitle:** Reading and Writing Data in Java

---

#### **Slide 2: Introduction to File I/O**

- **What is File I/O?**
  - Process of reading from and writing to files.
  - Essential for **data persistence** in applications.
- **Why use File I/O?**  
  ‚úÖ Store data permanently.  
  ‚úÖ Read configurations or process large datasets.  
  ‚úÖ Transfer information between applications.

---

#### **Slide 3: Java Classes for File I/O**

‚úÖ **Reading Data:**

- `Scanner` (reads text files)
- `FileReader` (reads characters from a file)
- `BufferedReader` (efficient line reading)

‚úÖ **Writing Data:**

- `PrintWriter` (writes text to a file)
- `FileWriter` (writes characters to a file)
- `BufferedWriter` (writes efficiently)

---

#### **Slide 4: Writing Data to a File (`PrintWriter`)**

```java
import java.io.*;

public class WriteToFile {
    public static void main(String[] args) throws IOException {
        PrintWriter writer = new PrintWriter("output.txt");
        writer.println("Hello, World!");
        writer.println(100);
        writer.close();
        System.out.println("Data written successfully.");
    }
}
```

‚úÖ **Creates a file and writes text to it.**  
‚úÖ **Uses `println()` to write different data types.**  
‚úÖ **Always close the file (`close()`).**

---

#### **Slide 5: Reading Data from a File (`Scanner`)**

```java
import java.io.*;
import java.util.Scanner;

public class ReadFromFile {
    public static void main(String[] args) throws IOException {
        File file = new File("output.txt");
        Scanner scanner = new Scanner(file);

        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }
        scanner.close();
    }
}
```

‚úÖ **Uses `Scanner` to read text line by line.**  
‚úÖ **Always close the file after reading.**

---

#### **Slide 6: Checking If a File Exists Before Writing**

```java
File file = new File("data.txt");

if (file.exists()) {
    System.out.println("File already exists.");
} else {
    System.out.println("File does not exist. Creating...");
}
```

‚úÖ **Prevents overwriting an existing file.**

---

#### **Slide 7: Appending Data to a File (`FileWriter`)**

```java
import java.io.*;

public class AppendToFile {
    public static void main(String[] args) throws IOException {
        FileWriter writer = new FileWriter("output.txt", true);
        writer.write("New data added.\n");
        writer.close();
    }
}
```

‚úÖ **Uses `FileWriter("file", true)` to append instead of overwrite.**

---

#### **Slide 8: Handling Exceptions in File I/O**

```java
try {
    File file = new File("nonexistent.txt");
    Scanner scanner = new Scanner(file);
} catch (FileNotFoundException e) {
    System.out.println("Error: File not found.");
}
```

‚úÖ **Use `try-catch` to handle errors** like missing files.

---

#### **Slide 9: Summary**

- **Reading Files:** Use `Scanner`, `FileReader`, or `BufferedReader`.
- **Writing Files:** Use `PrintWriter`, `FileWriter`, or `BufferedWriter`.
- **Handle Errors:** Always check if the file exists and use `try-catch`.

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.12. Reading Data from the Web

---

\*\* from your document. This will include key concepts, explanations, and examples to make the topic clear and engaging.

---

#### **Slide 1: Title Slide**

**Title:** Reading Data from the Web  
**Subtitle:** Fetching and Processing Online Data in Java

---

#### **Slide 2: Introduction**

- **What is Web Data Reading?**
  - Accessing and retrieving data from online sources (e.g., websites, APIs).
  - Java provides built-in classes to handle network communication.
- **Why Read Data from the Web?**  
  ‚úÖ Fetch real-time data (e.g., weather, stock prices).  
  ‚úÖ Automate web scraping.  
  ‚úÖ Interact with web services (APIs).

---

#### **Slide 3: Java Classes for Web Reading**

- **`URL` Class** (Connects to a website)
- **`URLConnection` Class** (Manages the connection)
- **`BufferedReader` Class** (Reads text from the connection)

---

#### **Slide 4: Connecting to a Website (`URL` Class)**

```java
import java.net.*;

public class URLExample {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://www.example.com");
        System.out.println("Protocol: " + url.getProtocol());
        System.out.println("Host: " + url.getHost());
        System.out.println("File: " + url.getFile());
    }
}
```

‚úÖ **Extracts parts of a URL.**  
‚úÖ **Throws `MalformedURLException` if URL is incorrect.**

---

#### **Slide 5: Reading Web Data (`URLConnection`)**

```java
import java.net.*;
import java.io.*;

public class ReadWebData {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://www.example.com");
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(url.openStream()));

        String line;
        while ((line = reader.readLine()) != null) {
            System.out.println(line);
        }
        reader.close();
    }
}
```

‚úÖ **Opens a stream to read web content.**  
‚úÖ **Uses `BufferedReader` for efficiency.**

---

#### **Slide 6: Handling Exceptions in Web Reading**

```java
try {
    URL url = new URL("https://invalid.url");
    BufferedReader reader = new BufferedReader(
        new InputStreamReader(url.openStream()));
} catch (MalformedURLException e) {
    System.out.println("Invalid URL.");
} catch (IOException e) {
    System.out.println("Error reading data.");
}
```

‚úÖ **Catches malformed URLs and connection issues.**

---

#### **Slide 7: Reading JSON Data from an API**

```java
import java.net.*;
import java.io.*;

public class ReadAPI {
    public static void main(String[] args) throws Exception {
        URL url = new URL("https://api.example.com/data");
        BufferedReader reader = new BufferedReader(
            new InputStreamReader(url.openStream()));

        String jsonData = reader.readLine();
        System.out.println("Data: " + jsonData);
        reader.close();
    }
}
```

‚úÖ **Fetches structured data from APIs.**  
‚úÖ **Can be processed using JSON libraries (`org.json`, `Gson`).**

---

#### **Slide 8: Best Practices for Web Data Reading**

‚úÖ **Always close the input stream (`reader.close()`).**  
‚úÖ **Use `try-catch` to handle exceptions.**  
‚úÖ **Check the website‚Äôs terms before scraping data.**  
‚úÖ **For large data, consider paginated requests.**

---

#### **Slide 9: Summary**

- **`URL` class** connects to a web address.
- **`URLConnection` and `BufferedReader`** help read web content.
- **Handle errors** (`MalformedURLException`, `IOException`).
- **Useful for fetching APIs, web scraping, and data automation.**

---

#### **Slide 10: Q&A**

"Any questions?"

---

Would you like this as a PowerPoint file? Or do you need any modifications? üòä

---

## 12.13. Case Study: Web Crawler

---

## End of the Chapter

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  height: 500px;
  }
  section::after {
  font-size: 20px;
  }

-->
