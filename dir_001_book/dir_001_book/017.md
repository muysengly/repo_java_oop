---
marp: false
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 17: Binary I/O

---

## 17.1. Introduction

---

### Slide 1: Introduction to Binary I/O

**Title:** Introduction to Binary I/O

**Content:**

- Java provides many classes for performing text I/O and binary I/O.
- Files can be classified as either text or binary.
- Text files can be processed using a text editor.
- Binary files are designed to be read by programs.

---

### Slide 2: Text Files vs. Binary Files

**Title:** Text Files vs. Binary Files

**Content:**

- Text files: Sequence of characters, readable by text editors.
- Binary files: Sequence of bits, readable by programs.
- Example: Java source programs are text files, Java class files are binary files.

---

### Slide 3: Efficiency of Binary Files

**Title:** Efficiency of Binary Files

**Content:**

- Binary files are more efficient to process than text files.
- Text files use character-encoding schemes like ASCII or Unicode.
- Binary files store data in raw binary format.

---

### Slide 4: Java I/O Classes

**Title:** Java I/O Classes

**Content:**

- Java offers many classes for file input and output.
- Categorized into text I/O classes and binary I/O classes.
- Text I/O: Scanner and PrintWriter.
- Binary I/O: Introduced in this chapter.

---

### Slide 5: Summary

**Title:** Summary

**Content:**

- Understanding the difference between text and binary files.
- Importance of binary files for efficiency.
- Overview of Java I/O classes for handling files.

---

### Slide 6: Next Steps

**Title:** Next Steps

**Content:**

- Explore how text I/O is handled in Java.
- Learn about the differences between text I/O and binary I/O.
- Understand the classes used for binary I/O.

---

---

## 17.2. How Is Text I/O Handled in Java?

---

### Slide 1: Introduction to Text I/O in Java

**Title:** Introduction to Text I/O in Java

**Content:**

- Text data is read using the `Scanner` class.
- Text data is written using the `PrintWriter` class.
- `File` object encapsulates file properties but not methods for I/O.

---

### Slide 2: Writing Text to a File

**Title:** Writing Text to a File

**Content:**

- Create a `PrintWriter` object for the file.
- Example:
  ```java
  PrintWriter output = new PrintWriter("temp.txt");
  output.print("Java 101");
  output.close();
  ```

---

### Slide 3: Reading Text from a File

**Title:** Reading Text from a File

**Content:**

- Create a `Scanner` object for the file.
- Example:
  ```java
  Scanner input = new Scanner(new File("temp.txt"));
  System.out.println(input.nextLine());
  ```

---

### Slide 4: Input and Output Classes

**Title:** Input and Output Classes

**Content:**

- Input classes contain methods to read data.
- Output classes contain methods to write data.
- Examples: `PrintWriter` (output), `Scanner` (input).

---

### Slide 5: Java I/O Programming

**Title:** Java I/O Programming

**Content:**

- Input object reads a stream of data from a file.
- Output object writes a stream of data to a file.
- Illustrated in Figure 17.1 of the textbook.

---

### Slide 6: Summary

**Title:** Summary

**Content:**

- Text I/O in Java uses `Scanner` and `PrintWriter`.
- `File` object encapsulates file properties.
- Methods for reading and writing data are in I/O classes.

---

---

## 17.3. Text I/O vs. Binary I/O

---

### Slide 1: Introduction to Text I/O vs. Binary I/O

**Title:** Introduction to Text I/O vs. Binary I/O

**Content:**

- Binary I/O does not involve encoding or decoding.
- Binary I/O is more efficient than text I/O.
- All files are stored in binary format.

---

### Slide 2: Text I/O

**Title:** Text I/O

**Content:**

- Built upon binary I/O.
- Provides abstraction for character encoding and decoding.
- JVM converts Unicode to file-specific encoding for text I/O.

---

### Slide 3: Binary I/O

**Title:** Binary I/O

**Content:**

- No conversions required.
- Exact value in memory is copied to the file.
- More efficient and portable across different machines.

---

### Slide 4: Example of Text I/O

**Title:** Example of Text I/O

**Content:**

- Writing string "199" to a file:
  - Unicode for '1' is 0x0031, '9' is 0x0039.
  - Stored as 0x31, 0x39, 0x39 in the file.

---

### Slide 5: Example of Binary I/O

**Title:** Example of Binary I/O

**Content:**

- Writing byte value 199 to a file:
  - Stored as 0xC7 in the file.
  - No encoding or decoding involved.

---

### Slide 6: Summary

**Title:** Summary

**Content:**

- Text I/O involves encoding/decoding, suitable for text files.
- Binary I/O is efficient, suitable for binary files.
- Use appropriate I/O based on file type and requirements.

---

### Slide 7: Next Steps

**Title:** Next Steps

**Content:**

- Explore binary I/O classes in Java.
- Learn how to use FileInputStream and FileOutputStream.
- Understand the benefits of using binary I/O for performance.

---

---

## 17.4. Binary I/O Classes

---

### Slide 1: Introduction to Binary I/O Classes

**Title:** Introduction to Binary I/O Classes

**Content:**

- Java provides various classes for binary I/O.
- Root classes: `InputStream` and `OutputStream`.
- Specialized classes for different purposes.

---

### Slide 2: FileInputStream and FileOutputStream

**Title:** FileInputStream and FileOutputStream

**Content:**

- Used for reading/writing bytes from/to files.
- Constructors:
  ```java
  FileInputStream(file: File)
  FileOutputStream(file: File)
  ```
- Example:
  ```java
  FileInputStream input = new FileInputStream("temp.dat");
  FileOutputStream output = new FileOutputStream("temp.dat");
  ```

---

### Slide 3: BufferedInputStream and BufferedOutputStream

**Title:** BufferedInputStream and BufferedOutputStream

**Content:**

- Used to improve I/O performance.
- Wrap around other input/output streams.
- Constructors:
  ```java
  BufferedInputStream(in: InputStream)
  BufferedOutputStream(out: OutputStream)
  ```

---

### Slide 4: DataInputStream and DataOutputStream

**Title:** DataInputStream and DataOutputStream

**Content:**

- Used to read/write primitive data types and strings.
- Extend `FilterInputStream` and `FilterOutputStream`.
- Example:
  ```java
  DataInputStream input = new DataInputStream(new FileInputStream("data.dat"));
  DataOutputStream output = new DataOutputStream(new FileOutputStream("data.dat"));
  ```

---

### Slide 5: Example of Using Data Streams

**Title:** Example of Using Data Streams

**Content:**

- Writing data:
  ```java
  output.writeUTF("John");
  output.writeDouble(85.5);
  ```
- Reading data:
  ```java
  String name = input.readUTF();
  double score = input.readDouble();
  ```

---

### Slide 6: Summary

**Title:** Summary

**Content:**

- Binary I/O classes provide efficient ways to handle binary data.
- Use `FileInputStream`/`FileOutputStream` for basic I/O.
- Use `BufferedInputStream`/`BufferedOutputStream` for performance.
- Use `DataInputStream`/`DataOutputStream` for primitive data types and strings.

---

### Slide 7: Next Steps

**Title:** Next Steps

**Content:**

- Explore a case study on copying files using binary I/O.
- Learn about object I/O for reading/writing objects.
- Understand random-access files for flexible file operations.

---

---

## 17.5. Case Study: Copying Files

---

---

## 17.6. Object I/O

---

### Slide 1: Introduction to Object I/O

**Title:** Introduction to Object I/O

**Content:**

- ObjectInputStream/ObjectOutputStream classes for reading/writing objects.
- Supports serialization and deserialization of objects.
- Extends DataInputStream/DataOutputStream functionality.

---

### Slide 2: ObjectOutputStream

**Title:** ObjectOutputStream

**Content:**

- Used to write objects to an output stream.
- Example:
  ```java
  ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream("object.dat"));
  output.writeObject(new Date());
  output.close();
  ```

---

### Slide 3: ObjectInputStream

**Title:** ObjectInputStream

**Content:**

- Used to read objects from an input stream.
- Example:
  ```java
  ObjectInputStream input = new ObjectInputStream(new FileInputStream("object.dat"));
  Date date = (Date) input.readObject();
  input.close();
  ```

---

### Slide 4: Serializable Interface

**Title:** Serializable Interface

**Content:**

- Objects must implement `Serializable` to be written to streams.
- Marker interface with no methods.
- Enables Java's serialization mechanism.

---

### Slide 5: Example of Object I/O

**Title:** Example of Object I/O

**Content:**

- Writing objects:
  ```java
  output.writeUTF("John");
  output.writeDouble(85.5);
  output.writeObject(new Date());
  ```
- Reading objects:
  ```java
  String name = input.readUTF();
  double score = input.readDouble();
  Date date = (Date) input.readObject();
  ```

---

### Slide 6: Handling Non-Serializable Fields

**Title:** Handling Non-Serializable Fields

**Content:**

- Use `transient` keyword for non-serializable fields.
- Example:
  ```java
  private transient A nonSerializableField;
  ```

---

### Slide 7: Serializing Arrays

**Title:** Serializing Arrays

**Content:**

- Arrays are serializable if all elements are serializable.
- Example:
  ```java
  int[] numbers = {1, 2, 3, 4, 5};
  output.writeObject(numbers);
  ```

---

### Slide 8: Summary

**Title:** Summary

**Content:**

- Object I/O supports reading/writing objects.
- Use `Serializable` interface for object serialization.
- Handle non-serializable fields with `transient`.
- Arrays can be serialized if elements are serializable.

---

### Slide 9: Next Steps

**Title:** Next Steps

**Content:**

- Explore RandomAccessFile for flexible file operations.
- Learn how to read/write data at any location in a file.
- Understand the benefits of random-access files.

---

---

## 17.7. Random-Access Files

---

### Slide 1: Introduction to Random-Access Files

**Title:** Introduction to Random-Access Files

**Content:**

- Allows reading and writing data at any location in the file.
- Provides more flexibility compared to sequential-access files.
- Useful for applications that require frequent updates to file contents.

---

### Slide 2: RandomAccessFile Class

**Title:** RandomAccessFile Class

**Content:**

- Implements `DataInput` and `DataOutput` interfaces.
- Supports both read and write operations.
- Example:
  ```java
  RandomAccessFile raf = new RandomAccessFile("file.dat", "rw");
  ```

---

### Slide 3: File Pointer

**Title:** File Pointer

**Content:**

- Special marker indicating the current position in the file.
- Moves forward as data is read or written.
- Can be moved to any position using `seek()` method.
- Example:
  ```java
  raf.seek(0); // Move to the beginning of the file
  raf.seek(raf.length()); // Move to the end of the file
  ```

---

### Slide 4: Reading and Writing Data

**Title:** Reading and Writing Data

**Content:**

- Read data using methods like `readInt()`, `readDouble()`.
- Write data using methods like `writeInt()`, `writeDouble()`.
- Example:
  ```java
  raf.writeInt(123);
  int value = raf.readInt();
  ```

---

### Slide 5: Example of RandomAccessFile

**Title:** Example of RandomAccessFile

**Content:**

- Demonstrates creating, writing, reading, and modifying a file.
- Example code:
  ```java
  RandomAccessFile raf = new RandomAccessFile("example.dat", "rw");
  raf.writeInt(100);
  raf.seek(0);
  int value = raf.readInt();
  raf.close();
  ```

---

### Slide 6: Summary

**Title:** Summary

**Content:**

- Random-access files provide flexibility for file operations.
- `RandomAccessFile` class supports both reading and writing.
- File pointer allows moving to any position in the file.
- Useful for applications requiring frequent file updates.

---

### Slide 7: Next Steps

**Title:** Next Steps

**Content:**

- Practice using `RandomAccessFile` for various file operations.
- Explore more advanced use cases and applications.
- Understand the benefits of random-access files for specific scenarios.

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  height: 500px;
  }
  section::after {
  font-size: 20px;
  }

-->
