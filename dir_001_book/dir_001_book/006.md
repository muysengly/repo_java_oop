---
marp: false
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 6: Methods

---

## 6.1. Introduction

---

### Purpose of Methods

- Methods encapsulate a collection of statements that perform specific operations, promoting code reusability and organization.
- Using methods helps avoid redundancy and simplifies code maintenance and debugging.

---

### Example of Reusable Code

- **Problem:** Calculate the sum of integers from 1 to 10, 20 to 37, and 35 to 49.
- **Solution:** Define a method `sum` that calculates the sum of integers within a given range.

**Example:**

- Calculating the sum of integers from various ranges can be done using a single method.

---

### Simplifying Code with Methods

- Methods can transform a set of repetitive code blocks into a single method invocation.

**Example:**

```java
public static int sum(int i1, int i2) {
    int result = 0;
    for (int i = i1; i <= i2; i++)
        result += i;
    return result;
}

public static void main(String[] args) {
    System.out.println("Sum from 1 to 10 is " + sum(1, 10));
    System.out.println("Sum from 20 to 37 is " + sum(20, 37));
    System.out.println("Sum from 35 to 49 is " + sum(35, 49));
}
```

---

**Explanation:**

- The `sum` method calculates the sum of integers within a given range.
- The `main` method calls the `sum` method with different arguments to calculate the sum for different ranges.

---

### Benefits of Using Methods

- **Code Reusability:** Methods can be reused across different parts of a program or even in different programs.
- **Modularity:** Breaking down a complex problem into smaller methods makes the code easier to understand and manage.
- **Maintainability:** Errors can be confined to specific methods, making debugging easier.

---

### Method Definition

- Methods have a header and a body. The header specifies the method's name, parameters, return type, and modifiers.
- The body contains the statements that define the method's behavior.

---

## 6.2. Common Mathematical Functions

---

Java provides a set of commonly used mathematical functions in the `java.lang.Math` class. These functions can perform various mathematical operations and are essential tools for developers. Here's a summary of the key points covered in this section:

---

### Math Methods

- The `Math` class includes several methods for performing basic numeric operations such as exponential, logarithm, square root, and trigonometric functions.

---

### Commonly Used Math Methods

- **`Math.pow(a, b)`**: Returns \(a^b\) (a raised to the power of b).
- **`Math.sqrt(a)`**: Returns the square root of \(a\).
- **`Math.sin(a)`**: Returns the sine of an angle \(a\) in radians.
- **`Math.cos(a)`**: Returns the cosine of an angle \(a\) in radians.
- **`Math.tan(a)`**: Returns the tangent of an angle \(a\) in radians.
- **`Math.asin(a)`**: Returns the arc sine of \(a\); the returned angle is in radians.

---

- **`Math.acos(a)`**: Returns the arc cosine of \(a\); the returned angle is in radians.
- **`Math.atan(a)`**: Returns the arc tangent of \(a\); the returned angle is in radians.
- **`Math.log(a)`**: Returns the natural logarithm (base \(e\)) of \(a\).
- **`Math.log10(a)`**: Returns the base-10 logarithm of \(a\).
- **`Math.exp(a)`**: Returns the exponential function \(e^a\).

---

### Constants

- The `Math` class includes mathematical constants such as:
  - **`Math.PI`**: The value of \(\pi\) (approximately 3.14159).
  - **`Math.E`**: The base of the natural logarithms (approximately 2.71828).

---

### Rounding Methods

- **`Math.ceil(a)`**: Returns the smallest integer greater than or equal to \(a\).
- **`Math.floor(a)`**: Returns the largest integer less than or equal to \(a\).
- **`Math.rint(a)`**: Returns the closest integer to \(a\).
- **`Math.round(a)`**: Returns the closest long or int to \(a\).

**Example:**

```java
double x = 2.0;
double y = 3.0;

System.out.println("Math.pow(x, y): " + Math.pow(x, y)); // 8.0
System.out.println("Math.sqrt(x): " + Math.sqrt(x)); // 1.4142135623730951
System.out.println("Math.sin(x): " + Math.sin(x)); // 0.9092974268256817
System.out.println("Math.PI: " + Math.PI); // 3.141592653589793
```

---

## 6.3. Character Data Type and Operations

---

**Character data type** in Java is used to represent a single character. Here are the key points covered in this section:

### 1. Declaring Character Variables:

- A character variable is declared using the `char` keyword.

**Example:**

```java
char letter = 'A';
```

---

### 2. ASCII and Unicode:

- Characters are internally stored as numbers. Each character corresponds to a unique numeric code.
- Java uses Unicode, which allows for a wide range of characters from different languages and symbol sets.

---

### 3. Escape Sequences:

- Special characters can be represented using escape sequences, starting with a backslash (`\`).
- Common escape sequences:
  - `\t`: Tab
  - `\n`: Newline
  - `\\`: Backslash
  - `\'`: Single quote
  - `\"`: Double quote

---

### 4. Casting Between char and Numeric Types:

- Characters can be cast to their corresponding numeric values and vice versa.

**Example:**

```java
char letter = 'A';
int number = (int) letter; // number will be 65
char anotherLetter = (char) 66; // anotherLetter will be 'B'
```

---

### 5. Character Operations:

- Characters can be compared using relational operators (e.g., `<`, `>`, `==`).

---

Java provides the `Character` class with several useful methods for character operations:

- `Character.isLetter(ch)`: Checks if the character is a letter.
- `Character.isDigit(ch)`: Checks if the character is a digit.
- `Character.isLowerCase(ch)`: Checks if the character is in lowercase.
- `Character.isUpperCase(ch)`: Checks if the character is in uppercase.
- `Character.toLowerCase(ch)`: Converts the character to lowercase.
- `Character.toUpperCase(ch)`: Converts the character to uppercase.

---

**Example:**

```java
char ch = 'A';

if (Character.isLetter(ch)) {
    System.out.println(ch + " is a letter.");
}

if (Character.isDigit(ch)) {
    System.out.println(ch + " is a digit.");
}

System.out.println("Lowercase: " + Character.toLowerCase(ch));
System.out.println("Uppercase: " + Character.toUpperCase('b'));
```

---

## 6.4. The String Type

---

In Java, the **String** type represents a sequence of characters. It is not a primitive type, but rather a reference type. Here are the key points covered in this section:

### 1. Creating Strings:

- Strings can be created by assigning a string literal to a String variable.
  ```java
  String message = "Welcome to Java";
  ```

---

### 2. String Concatenation:

- The `+` operator can be used to concatenate (join) two strings.
  ```java
  String s1 = "Hello";
  String s2 = "World";
  String s3 = s1 + " " + s2; // s3 becomes "Hello World"
  ```

---

### 3. Common String Methods:

- **`length()`**: Returns the length of the string.
  ```java
  int length = message.length(); // length is 15
  ```
- **`charAt(index)`**: Returns the character at the specified index.
  ```java
  char ch = message.charAt(0); // ch is 'W'
  ```
- **`substring(beginIndex, endIndex)`**: Returns a new string that is a substring of this string.
  ```java
  String sub = message.substring(0, 7); // sub is "Welcome"
  ```

---

- **`toLowerCase()`**: Converts all characters in the string to lowercase.
  ```java
  String lower = message.toLowerCase(); // lower is "welcome to java"
  ```
- **`toUpperCase()`**: Converts all characters in the string to uppercase.
  ```java
  String upper = message.toUpperCase(); // upper is "WELCOME TO JAVA"
  ```
- **`trim()`**: Removes leading and trailing whitespace.
  ```java
  String trimmed = message.trim();
  ```
- **`replace(oldChar, newChar)`**: Replaces occurrences of the specified character with a new character.
  ```java
  String replaced = message.replace('a', 'A'); // replaced is "Welcome to JAvA"
  ```

---

### 4. String Comparison:

- **`equals(Object obj)`**: Compares this string to the specified object.
  ```java
  boolean isEqual = s1.equals(s2); // false
  ```
- **`equalsIgnoreCase(String anotherString)`**: Compares this string to another string, ignoring case considerations.
  ```java
  boolean isEqualIgnoreCase = s1.equalsIgnoreCase("HELLO"); // true
  ```
- **`compareTo(String anotherString)`**: Compares two strings lexicographically.
  ```java
  int result = s1.compareTo(s2); // negative value because "Hello" is less than "World"
  ```

---

### 5. Immutability:

- Strings in Java are immutable, meaning once a string object is created, its content cannot be changed. Any operation that appears to modify a string actually creates a new string.

---

### 6. StringBuilder:

- For mutable sequences of characters, Java provides the `StringBuilder` class, which allows for modification without creating new objects.
  ```java
  StringBuilder sb = new StringBuilder("Hello");
  sb.append(" World");
  String result = sb.toString(); // result is "Hello World"
  ```

---

## 6.5. Case Studies

---

Practice.

---

## 6.6. Formatting Console Output

---

Java provides classes and methods to format console output in a visually appealing and easy-to-read manner. This section covers the key points on how to achieve this:

### 1. Using the `System.out.printf` Method:

- The `printf` method is used to format strings and numbers for console output.
- It follows the syntax:
  ```java
  System.out.printf(format, arguments);
  ```

---

### 2. Format Specifiers:

- Format specifiers define how the arguments will be formatted in the output string.
- Commonly used format specifiers include:
  - **`%b`**: Boolean value
  - **`%c`**: Character
  - **`%d`**: Decimal integer
  - **`%f`**: Floating-point number
  - **`%s`**: String
  - **`%x`**: Hexadecimal integer

---

### 3. Precision and Width:

- You can specify the width and precision of the formatted output.

**Example:**

```java
System.out.printf("The value of PI is approximately %.2f%n", Math.PI);
```

---

### 4. Flags:

- Flags modify the output format. Common flags include:
  - **`-`**: Left-justifies the output within the specified width.
  - **`+`**: Includes a plus or minus sign for numerical values.
  - **`0`**: Pads the output with leading zeros.
  - **`,`**: Uses a comma as a thousand separator.

---

**Example:**

```java
public class TestFormatting {
    public static void main(String[] args) {
        double pi = Math.PI;
        int number = 1234567;

        System.out.printf("PI: %10.4f%n", pi); // Right-justified, width 10, precision 4
        System.out.printf("Number with comma: %,d%n", number); // Comma as thousand separator
        System.out.printf("Padded number: %010d%n", number); // Leading zeros
    }
}
```

Output:

```
PI:     3.1416
Number with comma: 1,234,567
Padded number: 001234567
```

---

## 6.7. Case Study: <br> Converting Hexadecimals to Decimals

Practice.

---

## 6.8. Overloading Methods

---

This section discusses the concept of method overloading in Java, which allows you to define multiple methods with the same name but different parameter lists within the same class. The Java compiler determines which method to invoke based on the method signature (the method name and parameter list). Method overloading enhances the readability and clarity of programs by allowing methods that perform similar tasks with different types or numbers of parameters to share the same name.

---

### Key Points

- **Method Signature:** The combination of the method name and parameter list. Different methods with the same name must have different parameter lists.

---

### Example:

- `public static int max(int num1, int num2)`
- `public static double max(double num1, double num2)`
- `public static double max(double num1, double num2, double num3)`

---

- **Automatic Type Conversion:** If a method with an exact parameter match is not found, Java will perform automatic type conversion to find the best match. For instance, `max(2, 2.5)` will invoke `max(double num1, double num2)` since the integer 2 can be converted to a double.

- **Ambiguous Invocation:** This occurs when the compiler cannot determine the most specific match for a method invocation, resulting in a compile error. For example, having both `max(int num1, double num2)` and `max(double num1, int num2)` can cause ambiguity for the invocation `max(1, 2)`.

---

Method overloading makes programs more understandable by allowing similar methods to be called by the same name, provided that they differ in their parameter lists. However, overloaded methods must have different parameter lists; they cannot differ solely in return type or modifiers.

---

## 6.9. The Scope of Variables

---

This section discusses the concept of variable scope, which is the part of a program where a variable can be referenced. Key points include:

- **Local Variables:** Variables defined inside a method are called local variables. Their scope starts from the declaration point and continues to the end of the block that contains the variable.
- **Method Parameters:** These are local variables whose scope covers the entire method in which they are defined.

---

- **For-Loop Variables:** A variable declared in the initial-action part of a for-loop header has its scope within the entire loop. A variable declared inside the loop body has its scope limited to the loop body from its declaration point.
- **Scope Rules:** It is permissible to declare a local variable with the same name in different non-nested blocks within a method. However, it is not permissible to declare a local variable twice in the same block or in nested blocks.

The section emphasizes the importance of understanding variable scope to avoid common mistakes, such as attempting to use a variable outside its scope. For example, a variable declared in a for-loop cannot be accessed outside the loop.

---

## 6.10. Case Study: Generating Random Characters

---

Practice.

---

## 6.11. Method Abstraction and Stepwise Refinement

---

<style scoped>
  img {
    display: block;
    margin: 0 auto;
    height: 300px;
  }
</style>

### Method Abstraction

<img src="./images\image-20250307160034069.png" alt="image-20250307160034069" style="zoom: 80%;display: block; margin-left: auto; margin-right: auto; background-color:white;" />

---

### Method Abstraction

- Abstraction: The process of hiding implementation details and showing only the essential features of an object or method.
- Method Signature/Header: Specifies the method name, parameters, return type, and modifiers.
- Method Body: Contains the statements that define the method's behavior.
- Black Box Concept: Treats a method as a black box, focusing on its input, output, and behavior without concerning itself with the internal implementation.

---

### Stepwise Refinement

- Stepwise Refinement: A problem-solving technique that breaks down a complex problem into smaller, more manageable subproblems.

---

**Example:**

Print a calendar for a given year and month.

- **Step 1:** Define the main method and call the printMonth method.
- **Step 2:** Implement the printMonth method to print the calendar for a specific month.
- **Step 3:** Implement the printMonthTitle method to print the month and year.
- **Step 4:** Implement the printMonthBody method to print the days of the month.
- **Step 5:** Implement the getStartDay method to determine the starting day of the month.

---

- **Step 6:** Implement the getTotalNumberOfDaysInMonth method to calculate the total number of days in a month.
- **Step 7:** Implement the isLeapYear method to determine if a year is a leap year.
- **Step 8:** Refine and test the program.
- **Step 9:** Add more features or enhancements.
- **Step 10:** Refine and test the program again.
- **Step 11:** Repeat the process as needed.

---

### Top-Down and Bottom-Up Implementation

- **Top-Down Approach:** Start with the main method and work down to the lowest-level methods.
- **Bottom-Up Approach:** Start with the lowest-level methods and work up to the main method.

---

### Implementation Details

The section provides details on implementing specific methods, such as determining if a year is a leap year and computing the total number of days in a month. The complete program for printing the calendar is provided, demonstrating how stepwise refinement leads to a modular, easy-to-read, and maintainable code.

- **Leap Year Calculation:** A year is a leap year if it is divisible by 4 but not by 100, or if it is divisible by 400.
- **Total Number of Days in a Month:** The total number of days in a month depends on the month and year. February has 28 days in a non-leap year and 29 days in a leap year.

---

### Benefits of Stepwise Refinement

This approach breaks a large problem into smaller subproblems, making the program easier to write, reuse, debug, test, modify, and maintain. It also facilitates teamwork by allowing different programmers to work on different subproblems.

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  height: 500px;
  }
  section::after {
  font-size: 20px;
  }

-->
