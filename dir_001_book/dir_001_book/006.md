---
marp: true
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 6: Methods

---

## 6.1. Introduction

---

### Why Use Methods?

- **Key Problem**: Repetition in coding leads to inefficiency.
- **Solution**: Methods provide:
  - **Reusable Code**: Write once, use multiple times.
  - **Simplification**: Easier to read, debug, and maintain.
  - **Modularity**: Breaking down problems into smaller parts.

---

### Code Example Without Methods

- **Challenge**: Finding the sum of ranges (e.g., 1-10, 20-37) using repetitive code.
- Display code snippet that calculates sums without methods.

---

### Simplifying with a Method

- Introduce the `sum` method:

```java
public static int sum(int i1, int i2) {
    int result = 0;
    for (int i = i1; i <= i2; i++) {
        result += i;
    }
    return result;
}
```

- **Advantages**:
  - Single definition.
  - Flexible use: `sum(1, 10)`, `sum(20, 37)`, etc.

---

### Definition of Methods

- **What is a Method?**
  - A collection of statements grouped to perform an operation.
- Examples of predefined methods:
  - `System.out.println`
  - `Math.random`
  - `Math.pow`

---

## 6.2. Defining a Method

---

### Anatomy of a Method

## <img src="images\image-20250323202634172.png" alt="image-20250323202634172" />

---

### Components of a Method:

- **Modifier**: Accessibility of the method (e.g., `public`, `private`).
- **Return Value Type**: Data type of the value the method will return.
- **Method Name**: Identifies the method (e.g., `max`).
- **Parameters**: Inputs to the method, enclosed in parentheses.
- **Body**: Contains statements to perform the method's operations.

---

### Syntax of a Method

**Syntax**

```java
modifier returnValueType methodName(list of parameters) {
    // Method body
}
```

Explain:

- modifier: `public`, `private`, etc.
- returnValueType: `int`, `double`, `void`, etc.
- methodName: Name of the method.
- list of parameters: Variables passed to the method.
- Method body: Statements to perform the method's operations.

---

**Example:**

```java
public static int max(int num1, int num2) {
    if (num1 > num2)
        return num1;
    else
        return num2;
}
```

---

### Terminology

- **Method Header**: Includes modifiers, return value type, method name, and parameters.
- **Formal Parameters**: Variables in the method header.
- **Actual Parameters (Arguments)**: Values passed to the method during invocation.
- **Return Statement**: Returns a value or terminates the method.

---

### Key Notes

- **Value-Returning vs. Void Methods**:
  - Value-Returning: Returns a result (e.g., `int max`).
  - Void: Performs operations but returns no result (e.g., `void printMessage`).
- **Method Signature**: Combination of method name and parameter list.

---

## 6.3. Calling a Method

---

### Types of Method Calls

1. **Value-Returning Methods**:
   - Used as a value in expressions or assigned to variables.
   - Example:
     ```java
     int larger = max(3, 4);
     System.out.println(max(3, 4));
     ```
2. **Void Methods**:
   - Invoked as standalone statements.
   - Example:
     ```java
     System.out.println("Hello, World!");
     ```

---

### Flow of Control

- **When Called**: Program control is transferred to the method.
- **When Completed**: Control returns to the caller after execution.

---

**Example**:

```java
public static void main(String[] args) {
    int i = 5, j = 2;
    int k = max(i, j);
    System.out.println("The maximum of " + i + " and "
        + j + " is " + k);
}

public static int max(int num1, int num2) {
    return (num1 > num2) ? num1 : num2;
}
```

**Explanation**:

- The `max` method is invoked from `main`.
- Values `i` and `j` are passed to `num1` and `num2`.
- The result is returned and stored in `k`.

---

### Key Notes on Method Calls

- **Return Statement**: Required for value-returning methods.
- **Void Methods**: Do not require a return statement but can use `return;` to terminate early.
- **Reusable Code**: Methods simplify and modularize coding.

---

## 6.4. Void vs. Value-Returning Methods

---

### What Are Void Methods?

- **Definition**: A void method does not return any value.
- **Purpose**: Perform an operation or action.
- **Invocation**: Must be called as a statement.
- Example:
  ```java
  public static void printMessage(String message) {
      System.out.println(message);
  }
  ```
- Call Example: `printMessage("Hello, World!");`

---

### What Are Value-Returning Methods?

- **Definition**: A method that returns a value to the caller.
- **Purpose**: Perform an operation and provide a result.
- **Invocation**: Can be used in expressions or assigned to variables.
- Example:
  ```java
  public static int add(int a, int b) {
      return a + b;
  }
  ```
- Call Example:
  ```java
  int sum = add(5, 10);
  System.out.println(sum);
  ```

---

### Key Differences Between Void and Value-Returning Methods

| Feature              | Void Method          | Value-Returning Method             |
| -------------------- | -------------------- | ---------------------------------- |
| **Return Type**      | `void`               | Data type (e.g., `int`)            |
| **Return Statement** | Optional (`return;`) | Required with a value              |
| **Usage**            | Standalone statement | Assign to variables or expressions |

---

### Example Comparison

- **Void Method Example**:
  ```java
  public static void printGrade(double score) {
      if (score >= 90.0) System.out.println('A');
      else if (score >= 80.0) System.out.println('B');
      else if (score >= 70.0) System.out.println('C');
      else System.out.println('F');
  }
  ```
- **Value-Returning Method Example**:
  ```java
  public static char getGrade(double score) {
      if (score >= 90.0) return 'A';
      else if (score >= 80.0) return 'B';
      else if (score >= 70.0) return 'C';
      else return 'F';
  }
  ```

---

### When to Use Each Method

- **Void Methods**:
  - When no value needs to be returned (e.g., logging, printing).
- **Value-Returning Methods**:
  - When a result is needed for further operations.

---

## 6.5. Passing Arguments by Values

---

### What is Passing Arguments by Values?

- **Definition**: When a method is invoked, the value of the argument is passed to the method’s parameter.
- **Key Point**:
  - The method works with the value passed, not the actual variable.
  - Changes made to the parameter inside the method do not affect the argument outside.

---

### Example: Incrementing a Value

- **Code Snippet**:

  ```java
  public class Increment {
      public static void main(String[] args) {
          int x = 1;
          System.out.println("Before the call, x is " + x);
          increment(x);
          System.out.println("After the call, x is " + x);
      }

      public static void increment(int n) {
          n++;
          System.out.println("n inside the method is " + n);
      }
  }
  ```

- **Output Explanation**:
  - The variable `x` remains unchanged (pass-by-value).

---

### Swapping Values Example

- **Code Snippet**:
  ```java
  public static void swap(int n1, int n2) {
      int temp = n1;
      n1 = n2;
      n2 = temp;
  }
  ```
- **Behavior**:
  - Inside the method, the values of `n1` and `n2` swap.
  - The original arguments (outside the method) remain unchanged.

---

### Key Notes on Pass-By-Value

- **Parameter Order Association**: Arguments must match parameters in:
  - **Order**
  - **Number**
  - **Compatible Type**
- **Effects**:
  - Arguments are not modified outside the method.
  - Provides protection for original variables.

---

### When and Why to Use Pass-By-Value?

- **Advantages**:
  - Ensures method isolation.
  - Prevents unintentional modification of original data.
- **Best Use Cases**:
  - Calculations and operations where original data must remain intact.

---

## 6.6. Modularizing Code

---

### What is Modularizing Code?

- **Definition**: Dividing code into smaller, manageable methods.
- **Benefits**:
  - **Improves readability**: Easier to understand the logic.
  - **Simplifies debugging**: Errors are localized to specific methods.
  - **Promotes reusability**: Methods can be reused in other programs.

---

### Example: Greatest Common Divisor (GCD)

- **Code Snippet**:
  ```java
  public static int gcd(int n1, int n2) {
      int gcd = 1;
      int k = 2; // Potential gcd
      while (k <= n1 && k <= n2) {
          if (n1 % k == 0 && n2 % k == 0)
              gcd = k; // Update gcd
          k++;
      }
      return gcd;
  }
  ```
- **Explanation**:
  - Isolates GCD logic into a method.
  - Can be reused in other programs.

---

### Advantages of Modular Design

1. **Reduces Redundancy**: Removes duplicate code.
2. **Encapsulation**: Focuses on specific problems within methods.
3. **Enhances Maintenance**: Modular code is easier to update.

---

### Applying Modular Design

- Rewrite complex problems using methods:
  - **Example**: Prime Number Program
    - Submethods: `isPrime`, `printPrimeNumbers`
  - Results: Clearer logic and reusable methods.

---

### Key Notes

- Use modularization to divide large programs into smaller pieces.
- Modular methods promote efficient development and higher-quality code.
- Debugging modular methods narrows down potential errors.

---

## 6.7. Case Study: Converting Hexadecimals to Decimals

---

## 6.8. Overloading Methods

---

Here’s a well-structured outline for your slide on **6.8 Overloading Methods**:

---

### Title Slide

- Title: **6.8 Overloading Methods**
- Subtitle: Enhancing Method Flexibility

---

### What is Method Overloading?

- **Definition**: A method is overloaded when multiple methods share the same name but differ in:
  - **Number of parameters**.
  - **Type of parameters**.
  - **Order of parameters**.
- **Key Advantage**: Enhances code readability and usability by providing flexibility.

---

### Example of Overloading

- **Code Snippet**:

  ```java
  public static int max(int num1, int num2) {
      return (num1 > num2) ? num1 : num2;
  }

  public static double max(double num1, double num2) {
      return (num1 > num2) ? num1 : num2;
  }

  public static double max(double num1, double num2, double num3) {
      return Math.max(num1, Math.max(num2, num3));
  }
  ```

- **Explanation**:
  - The `max` method is overloaded to handle both integers and doubles.
  - One version supports two numbers, another handles three.

---

### Benefits of Overloading Methods

- **Improves Code Reusability**: No need for multiple distinct method names.
- **Enhances Maintainability**: Related functionality grouped under the same name.
- **Simplifies API Design**: More intuitive to users.

---

### Rules for Overloading

- Methods must have the **same name** but differ in:
  - **Parameter count**.
  - **Parameter type**.
  - **Parameter order**.
- Return type alone **cannot** distinguish overloaded methods.

---

### Ambiguous Overloading

- **What is Ambiguity?**
  - When the compiler cannot determine which method to call due to similar parameter types.

**Example**: Ambiguous Overloading

```java
public static void print(int num, double value) { ... }
public static void print(double value, int num) { ... }
```

**Explain:**

- Ambiguity arises if you call `print(5, 5);`.
- Compiler cannot determine which method to invoke.
- Solution: Avoid ambiguous overloading.

---

## 6.9. The Scope of Variables

---

### What is the Scope of a Variable?

- **Definition**: The scope of a variable refers to the portion of the program where the variable can be accessed.
- **Types of Variable Scope**:
  - **Local Variables**: Defined inside methods, constructors, or blocks; accessible only within their defining scope.
  - **Instance Variables**: Defined outside methods but inside a class; accessible by all methods of the class.
  - **Class Variables**: Declared with the keyword `static`; shared among all instances of the class.

---

### Local Variables in Methods

- **Characteristics**:
  - Declared within a method, block, or constructor.
  - Memory allocated only during method execution.
  - Not accessible outside the method or block where defined.
- **Example**:
  ```java
  public void calculateSum() {
      int sum = 0; // Local variable
      for (int i = 1; i <= 10; i++) {
          sum += i;
      }
      System.out.println(sum); // Accessible within the method
  }
  ```

---

### Instance Variables

- **Characteristics**:
  - Declared in a class but outside methods.
  - Each object has its own copy of instance variables.
- **Example**:

  ```java
  public class Student {
      String name; // Instance variable
      int age; // Instance variable

      public void displayInfo() {
          System.out.println("Name: " + name);
          System.out.println("Age: " + age);
      }
  }
  ```

---

### Class Variables

- **Characteristics**:
  - Shared among all instances of a class.
  - Declared with the `static` modifier.
- **Example**:

  ```java
  public class Employee {
      static int employeeCount; // Class variable

      public static void increaseCount() {
          employeeCount++;
      }
  }
  ```

---

### Key Notes on Variable Scope

- **Block Scope**: Defined within braces `{}`; limited to that block.
- **Method Scope**: Accessible only within the method.
- **Class Scope**: Instance and static variables available throughout the class.
- **Lifetime**: Local variables exist during execution; instance and static persist as long as the object/class exists.

---

## 6.10. Case Study: <br> Generating Random Characters

---

## 6.11. Method Abstraction and Stepwise Refinement

---

<img src="images\image-20250323202825907.png" alt="image-20250323202825907"  />

---

### Title Slide

- Title: **6.11 Method Abstraction and Stepwise Refinement**
- Subtitle: Designing Complex Solutions Methodically

---

### What is Method Abstraction?

- **Definition**:
  - The process of focusing on _what_ a method does rather than _how_ it does it.
  - Encourages modular programming by hiding implementation details.
- **Advantages**:
  - Simplifies code readability.
  - Allows reusability and scalability.

---

### Stepwise Refinement Process

1. **Divide a Complex Problem**:
   - Break down into smaller, manageable subproblems.
2. **Design Each Step Separately**:
   - Focus on solving subproblems independently.
3. **Combine Solutions**:
   - Integrate smaller methods to solve the overall problem.

---

### Example: Printing Prime Numbers

- **Step 1**: Write `isPrime` method to check if a number is prime.
- **Step 2**: Write `printPrimeNumbers` method to print prime numbers.
- **Step 3**: Combine methods to create the final solution.

---

**Example**: Printing Prime Numbers

```java
public static boolean isPrime(int number) {
    for (int divisor = 2; divisor <= number / 2; divisor++) {
        if (number % divisor == 0)
            return false;
    }
    return true;
}

public static void printPrimeNumbers(int count) {
    int number = 2;
    int printed = 0;
    while (printed < count) {
        if (isPrime(number)) {
            System.out.println(number);
            printed++;
        }
        number++;
    }
}
```

---

### Benefits of Stepwise Refinement

- **Modular Design**:
  - Easier to manage and debug.
- **Improved Collaboration**:
  - Independent modules can be developed simultaneously.
- **Encourages Code Reuse**:
  - Methods can be reused in different programs.

---

### Key Notes

- Focus on high-level logic first and refine the implementation step by step.
- Use abstraction to isolate complexity and simplify solutions.
- Refined methods should work together seamlessly.

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  }
  section::after {
  font-size: 20px;
  }

-->
