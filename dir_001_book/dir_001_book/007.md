---
marp: false
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 7: <br> Single-Dimensional Arrays

---

## 7.1. Introduction

---

### Arrays in Programming

Arrays are fundamental structures in programming that allow the storage and manipulation of collections of data. Here's an overview of the key points covered in this section:

---

### The Need for Arrays:

- When handling a large number of values, arrays provide an organized way to store and access data.
- For example, to read 100 numbers, compute their average, and find out how many numbers are above the average, arrays allow the storage of all 100 numbers in a single structure.

---

### Efficient Data Storage:

- Arrays store a fixed-size sequential collection of elements of the same type.
- Instead of declaring multiple variables, an array allows the storage of values using a single array variable with indexed elements.

---

### Example Scenario:

- To store 100 numbers: Declare an array and use indexes to access individual elements.
- This approach avoids the impracticality of declaring and managing 100 separate variables.

---

### Structure of an Array:

- Arrays are created with a specific size and element type.
- Once created, the size of an array is fixed and cannot be changed.

By understanding the necessity and benefits of arrays, programmers can manage large collections of data efficiently and perform complex operations more effectively. This section sets the stage for delving into the details of arrays and their operations in the subsequent sections.

---

## 7.2. Array Basics

---

**Arrays** are essential structures in Java used to store collections of data. Here's a summary of the key points covered in this section:

### Declaring Array Variables:

- An array variable must be declared to reference the array and specify the element type.
- Syntax:
  ```java
  elementType[] arrayRefVar;
  // or
  elementType arrayRefVar[];
  ```

---

### Creating Arrays:

- Declaration alone does not allocate memory; use the `new` operator to create an array:

**Syntax:**

```java
arrayRefVar = new elementType[arraySize];
// or combine declaration and creation:
elementType[] arrayRefVar = new elementType[arraySize];
```

**Example:**

```java
double[] myList = new double[10];
```

---

### Array Size and Default Values:

- The size of an array is fixed once it is created and accessed using `arrayRefVar.length`.
- Default values: 0 for numeric types, `\u0000` for `char`, and `false` for `boolean`.

---

### Accessing Array Elements:

- Access elements using the index: `arrayRefVar[index]`.
- Indices are 0-based, ranging from 0 to `arrayRefVar.length - 1`.

**Example:**

```java
myList[0] = 5.6;
```

---

### Array Initializers:

- Shorthand notation for declaring, creating, and initializing arrays in one statement:
  ```java
  elementType[] arrayRefVar = {value0, value1, ..., valuek};
  // Example:
  double[] myList = {1.9, 2.9, 3.4, 3.5};
  ```

---

### Processing Arrays:

- **Initialization:** Use loops to initialize arrays with input values or random values.
  ```java
  for (int i = 0; i < myList.length; i++) {
      myList[i] = Math.random() * 100;
  }
  ```

---

- **Displaying:** Print each element using a loop.
  ```java
  for (int i = 0; i < myList.length; i++) {
      System.out.print(myList[i] + " ");
  }
  ```

---

- **Summing:** Calculate the sum of all elements.
  ```java
  double total = 0;
  for (int i = 0; i < myList.length; i++) {
      total += myList[i];
  }
  ```

---

- **Finding Maximum:** Determine the largest element.
  ```java
  double max = myList[0];
  for (int i = 1; i < myList.length; i++) {
      if (myList[i] > max) max = myList[i];
  }
  ```

---

### Foreach Loops:

- Java provides a convenient `foreach` loop to traverse arrays without using an index.
  ```java
  for (double e : myList) {
      System.out.println(e);
  }
  ```

---

### Common Errors:

- **Off-by-One Error:** Ensure indices range within 0 to `arrayRefVar.length - 1`.
- **ArrayIndexOutOfBoundsException:** Avoid accessing elements beyond the array bounds.

By understanding these basics, you can effectively declare, create, initialize, and manipulate arrays in Java, enabling you to handle collections of data efficiently.

---

## 7.3. Case Study: Analyzing Numbers

---

## 7.4. Case Study: Deck of Cards

---

## 7.5. Copying Arrays

---

When you need to duplicate an array or part of an array, there are specific methods to use rather than simple assignment. Here's a summary of key points:

### Assignment vs. Copying:

- Using the assignment statement (`=`) does not copy array contents. It only copies the reference, causing both variables to refer to the same array.
  **Example:**
  ```java
  list2 = list1;
  ```
  Both `list1` and `list2` will reference the same array after this statement.

---

### Methods to Copy Arrays:

- **Using a Loop:**

  - Manually copy each element from the source array to the target array.
    **Example:**
    `java
int[] sourceArray = {2, 3, 1, 5, 10};
int[] targetArray = new int[sourceArray.length];
for (int i = 0; i < sourceArray.length; i++) {
    targetArray[i] = sourceArray[i];
}
`

---

- **Using `System.arraycopy()`:**

  - A built-in method provided by the `System` class for copying arrays.
  - Syntax:
    `java
System.arraycopy(sourceArray, srcPos, targetArray, tarPos, length);
`
    **Example:**
    `java
int[] sourceArray = {2, 3, 1, 5, 10};
int[] targetArray = new int[sourceArray.length];
System.arraycopy(sourceArray, 0, targetArray, 0, sourceArray.length);
`
  - `srcPos` and `tarPos` denote the starting positions in the source and target arrays, respectively. `length` is the number of elements to copy.

---

- **Using `clone()`:**
  - This method creates a shallow copy of the array.
    **Example:**
    `java
int[] sourceArray = {2, 3, 1, 5, 10};
int[] clonedArray = sourceArray.clone();
`

---

### Important Notes:

- **Shallow Copy:** Methods like `clone()` create a shallow copy, meaning they copy the elements but not any objects that the elements might reference.
- **Garbage Collection:** When an array reference is reassigned, the original array may become unreferenced and eligible for garbage collection.

Using these methods ensures that arrays are copied correctly, maintaining data integrity and avoiding unintended side effects from reference sharing.

---

## 7.6. Passing Arrays to Methods

---

When passing an array to a method, the reference of the array is passed, not the actual array. This allows the method to modify the original array. Here's a summary of the key points:

### Passing an Array to a Method:

- Similar to passing primitive type values, arrays can also be passed as arguments to methods.
- When an array is passed, the reference to the array is passed, allowing the method to access and modify the array elements.

---

**Example Method to Print Array Elements:**

```java
public static void printArray(int[] array) {
    for (int i = 0; i < array.length; i++) {
        System.out.print(array[i] + " ");
    }
}
```

- You can invoke this method by passing an array:
  ```java
  printArray(new int[]{3, 1, 2, 6, 4, 2});
  ```

---

### Passing-by-Value and Passing-by-Sharing:

- Java uses pass-by-value to pass arguments to a method.
- For a primitive type, the value of the variable is passed.
- For arrays, the reference to the array is passed, making it behave like pass-by-sharing. Changes made to the array within the method affect the original array.

---

**Example Demonstrating Pass-by-Sharing:**

```java
public class TestArrayArguments {
    public static void main(String[] args) {
        int x = 1;
        int[] y = new int[10];
        m(x, y);
        System.out.println("x is " + x);
        System.out.println("y[0] is " + y[0]);
    }

    public static void m(int number, int[] numbers) {
        number = 1001;
        numbers[0] = 5555;
    }
}
```

- After invoking `m(x, y)`, `x` remains 1, but `y[0]` becomes 5555 because the reference to the array `y` is passed to the method `m`.

---

### Arrays in Memory:

- Arrays are objects in Java stored in the heap.
- The reference to the array is stored in the stack, while the array elements are stored in the heap.

---

**Example:** Swapping Elements in an Array

```java
public class TestPassArray {
    public static void main(String[] args) {
        int[] a = {1, 2};

        // Swap elements using the swap method
        System.out.println("Before invoking swap");
        System.out.println("array is {" + a[0] + ", " + a[1] + "}");
        swap(a[0], a[1]);
        System.out.println("After invoking swap");
        System.out.println("array is {" + a[0] + ", " + a[1] + "}");

        // Swap elements using the swapFirstTwoInArray method
        System.out.println("Before invoking swapFirstTwoInArray");
        System.out.println("array is {" + a[0] + ", " + a[1] + "}");
        swapFirstTwoInArray(a);
        System.out.println("After invoking swapFirstTwoInArray");
        System.out.println("array is {" + a[0] + ", " + a[1] + "}");
    }

    /** Swap two variables */
    public static void swap(int n1, int n2) {
        int temp = n1;
        n1 = n2;
        n2 = temp;
    }

    /** Swap the first two elements in the array */
    public static void swapFirstTwoInArray(int[] array) {
        int temp = array[0];
        array[0] = array[1];
        array[1] = temp;
    }
}
```

---

- The first `swap` method fails to swap the elements because it operates on primitive values. The second method `swapFirstTwoInArray` successfully swaps the first two elements in the array because it operates on the array reference.

By understanding these concepts, you can effectively pass arrays to methods and utilize the array references to manipulate array elements within methods.

---

## 7.7. Returning an Array from a Method

---

**Returning an array** from a method in Java is straightforward. The method should return the array's reference. Here's a summary of the key points:

### Method Declaration:

- The method should specify the return type as an array.
- Syntax:
  ```java
  public static elementType[] methodName(parameters) {
      // Method body
  }
  ```

---

**Example:** Reversing an Array:

- The example provided demonstrates a method that reverses the elements of an array.
  **Example Code:**
  ```java
  public static int[] reverse(int[] list) {
      int[] result = new int[list.length];
      for (int i = 0, j = result.length - 1; i < list.length; i++, j--) {
          result[j] = list[i];
      }
      return result;
  }
  ```
  - The method `reverse` creates a new array `result` to store the reversed elements.
  - A loop copies elements from the input array `list` to the `result` array in reverse order.
  - The method returns the `result` array.

---

### Example Usage:

- To use the `reverse` method:
  ```java
  int[] list1 = {1, 2, 3, 4, 5, 6};
  int[] list2 = reverse(list1);
  ```
- The `list2` array will contain the elements of `list1` in reverse order.

---

**Important Notes:**

- When a method returns an array, it returns a reference to the array. The caller can use this reference to access and modify the array elements.
- Returning a reference is efficient because it avoids copying the entire array.

By understanding how to return arrays from methods, you can write more flexible and reusable code in Java.

---

## 7.8. Case Study: Counting the Occurrences of Each Letter

---

## 7.9. Variable-Length Argument Lists

---

Java allows methods to accept a variable number of arguments of the same type, which can be treated as an array. Here's a summary of the key points covered in this section:

---

### Syntax for Variable-Length Parameters:

- In the method declaration, use the ellipsis (`...`) to specify a variable-length parameter.
- Syntax:
  ```java
  typeName... parameterName
  ```

---

### Rules for Variable-Length Parameters:

- Only one variable-length parameter can be specified in a method.
- The variable-length parameter must be the last parameter in the method. Any regular parameters must precede it.

---

### Passing Arguments:

- Java treats the variable-length parameter as an array.
- You can pass an array or a variable number of arguments to the variable-length parameter.

---

**Example Method:**

**Example of a method that prints the maximum value in a list of an unspecified **number of values:

---

```java
public class VarArgsDemo {
    public static void main(String[] args) {
        printMax(34, 3, 3, 2, 56.5);
        printMax(new double[]{1, 2, 3});
    }

    public static void printMax(double... numbers) {
        if (numbers.length == 0) {
            System.out.println("No argument passed");
            return;
        }

        double result = numbers[0];
        for (int i = 1; i < numbers.length; i++) {
            if (numbers[i] > result)
                result = numbers[i];
        }
        System.out.println("The max value is " + result);
    }
}
```

---

- Line 3 invokes the `printMax` method with a variable-length argument list passed to the `numbers` array. If no arguments are passed, the length of the array is 0 (line 8).
- Line 4 invokes the `printMax` method with an array.

---

### Important Notes:

- When invoking a method with a variable number of arguments, Java creates an array and passes the arguments to it.

By understanding the use of variable-length argument lists, you can write more flexible and versatile methods in Java.

---

## 7.10. Searching Arrays

---

Searching is the process of looking for a specific element within an array. This section introduces two common searching algorithms: linear search and binary search.

### Linear Search:

- Linear search compares the key element sequentially with each element in the array.
- It continues until the key is found or the array is exhausted.
- If a match is found, the linear search returns the index of the element; otherwise, it returns -1.

---

**Example Implementation:**

```java
public class LinearSearch {
    public static int linearSearch(int[] list, int key) {
        for (int i = 0; i < list.length; i++) {
            if (key == list[i]) {
                return i;
            }
        }
        return -1;
    }
}
```

---

### Binary Search:

- Binary search is more efficient than linear search but requires the array to be sorted.
- It compares the key with the middle element of the array:
  1.  If the key is less than the middle element, it searches the first half.
  2.  If the key is equal to the middle element, the search ends.
  3.  If the key is greater than the middle element, it searches the second half.
- This process continues, halving the search range each time, until the key is found or the range is empty.

---

**Example Implementation:**

```java
public class BinarySearch {
    public static int binarySearch(int[] list, int key) {
        int low = 0;
        int high = list.length - 1;

        while (high >= low) {
            int mid = (low + high) / 2;
            if (key < list[mid]) {
                high = mid - 1;
            } else if (key == list[mid]) {
                return mid;
            } else {
                low = mid + 1;
            }
        }
        return -low - 1; // Key not found
    }
}
```

---

**Efficiency Comparison:**

- **Linear Search:** Time complexity is O(n), where n is the number of elements. It is suitable for small or unsorted arrays.
- **Binary Search:** Time complexity is O(log n), where n is the number of elements. It is efficient for large, sorted arrays.

By understanding these searching algorithms, you can choose the most appropriate method for finding elements in arrays based on their size and whether they are sorted.

---

## 7.11. Sorting Arrays

---

Sorting is a common task in computer programming, and many algorithms have been developed to accomplish it. This section introduces an intuitive sorting algorithm called selection sort.

### Selection Sort Algorithm:

- The selection sort algorithm sorts an array by repeatedly finding the smallest element and swapping it with the element at the current position.
- The process is repeated for each position in the array until the entire array is sorted.

---

### Steps of Selection Sort:

- **Find the Minimum:** Find the smallest number in the list and swap it with the first element.
- **Repeat the Process:** Find the smallest number in the remaining list and swap it with the second element.
- Continue this process until only a single number remains unsorted.

---

**Example:**

- To sort the list {2, 9, 5, 4, 8, 1, 6}, the selection sort algorithm would work as follows:
  - Select 1 (the smallest) and swap it with 2 (the first element).
  - Select 2 (the smallest) and swap it with 9 (the first element in the remaining list).
  - Continue this process for the rest of the elements until the entire list is sorted.

---

### Implementing Selection Sort:

- The selection sort can be implemented in Java with a nested loop:

  ```java
  public class SelectionSort {
      /** The method for sorting the numbers */
      public static void selectionSort(double[] list) {
          for (int i = 0; i < list.length - 1; i++) {
              // Find the minimum in the list[i..list.length-1]
              double currentMin = list[i];
              int currentMinIndex = i;

              for (int j = i + 1; j < list.length; j++) {
                  if (currentMin > list[j]) {
                      currentMin = list[j];
                      currentMinIndex = j;
                  }
              }

              // Swap list[i] with list[currentMinIndex] if necessary
              if (currentMinIndex != i) {
                  list[currentMinIndex] = list[i];
                  list[i] = currentMin;
              }
          }
      }
  }
  ```

- This method sorts an array of double elements using selection sort.

---

### Tracing the Algorithm:

- To understand the selection sort method better, trace it with the following statements:
  ```java
  double[] list = {1, 9, 4.5, 6.6, 5.7, -4.5};
  SelectionSort.selectionSort(list);
  ```

---

### Modifying Selection Sort:

- To sort numbers in decreasing order, modify the selectionSort method to find the maximum instead of the minimum in each iteration.

By understanding and implementing the selection sort algorithm, you can effectively sort arrays in Java and apply the concepts to other sorting algorithms.

---

## 7.12. The Arrays Class

---

The `java.util.Arrays` class provides several useful methods for array manipulation, including sorting, searching, comparing, filling, and converting arrays to strings. Here are the key points covered in this section:

---

### Sorting Arrays:

- **`sort` Method:** Sorts an entire array or a specified range within an array.
  ```java
  double[] numbers = {6.0, 4.4, 1.9, 2.9, 3.4, 3.5};
  java.util.Arrays.sort(numbers); // Sorts the entire array
  char[] chars = {'a', 'A', '4', 'F', 'D', 'P'};
  java.util.Arrays.sort(chars, 1, 3); // Sorts part of the array (chars[1] to chars[2])
  ```

---

- **`parallelSort` Method:** Similar to `sort` but optimized for multi-core processors.
  ```java
  java.util.Arrays.parallelSort(numbers); // Sorts the entire array in parallel
  java.util.Arrays.parallelSort(chars, 1, 3); // Sorts part of the array in parallel
  ```

---

### Searching Arrays:

- **`binarySearch` Method:** Searches for a key in a sorted array and returns its index. If the key is not found, returns `-(insertionPoint + 1)`.
  ```java
  int[] list = {2, 4, 7, 10, 11, 45, 50, 59, 60, 66, 69, 70, 79};
  int index = java.util.Arrays.binarySearch(list, 11); // Returns 4
  int notFoundIndex = java.util.Arrays.binarySearch(list, 12); // Returns -6
  ```

---

### Comparing Arrays:

- **`equals` Method:** Checks if two arrays are strictly equal (same length and elements).
  ```java
  int[] list1 = {2, 4, 7, 10};
  int[] list2 = {2, 4, 7, 10};
  boolean areEqual = java.util.Arrays.equals(list1, list2); // Returns true
  ```

---

### Filling Arrays:

- **`fill` Method:** Fills an entire array or a specified range within an array with a given value.
  ```java
  int[] list = new int[10];
  java.util.Arrays.fill(list, 5); // Fills entire array with 5
  java.util.Arrays.fill(list, 2, 5, 8); // Fills list[2] to list[4] with 8
  ```

---

### Converting Arrays to Strings:

- **`toString` Method:** Returns a string representation of the array.
  ```java
  int[] list = {2, 4, 7, 10};
  String arrayString = java.util.Arrays.toString(list); // Returns "[2, 4, 7, 10]"
  ```

By utilizing the methods provided by the `java.util.Arrays` class, programmers can efficiently perform common operations on arrays, enhancing their productivity and making their code more readable and maintainable.

---

## 7.13. Command-Line Arguments

---

Java programs can receive input from the command line through **command-line arguments**. This section covers how to handle and use these arguments.

### The `main` Method:

- The `main` method in Java can receive command-line arguments as an array of strings (`String[] args`).
- Syntax:
  ```java
  public static void main(String[] args) {
      // Code to process args
  }
  ```

---

### Passing Arguments:

- Command-line arguments are passed when executing a program from the command line.
  **Example:**
  ```java
  java TestMain arg0 arg1 arg2
  ```
  - `arg0`, `arg1`, and `arg2` are the arguments passed to `TestMain`.

---

### Handling Arguments in the `main` Method:

- You can access and process each argument using `args` array in the `main` method.
  **Example:**
  ```java
  public class TestMain {
      public static void main(String[] args) {
          for (int i = 0; i < args.length; i++) {
              System.out.println(args[i]);
          }
      }
  }
  ```

---

### Creating Arrays for Arguments:

- The Java interpreter creates an array to hold the command-line arguments and passes it to `args`.
- If no arguments are passed, the array length is 0.

**Example Case Study: Simple Calculator**

- Create a program to perform basic arithmetic operations using command-line arguments.
  **Example:**

---

```java
public class Calculator {
    public static void main(String[] args) {
        if (args.length != 3) {
            System.out.println("Usage: java Calculator operand1 operator operand2");
            System.exit(1);
        }

        int result = 0;
        switch (args[1].charAt(0)) {
            case '+':
                result = Integer.parseInt(args[0]) + Integer.parseInt(args[2]);
                break;
            case '-':
                result = Integer.parseInt(args[0]) - Integer.parseInt(args[2]);
                break;
            case '.':
                result = Integer.parseInt(args[0]) * Integer.parseInt(args[2]);
                break;
            case '/':
                result = Integer.parseInt(args[0]) / Integer.parseInt(args[2]);
                break;
        }

        System.out.println(args[0] + " " + args[1] + " " + args[2] + " = " + result);
    }
}
```

---

- In this example, the program performs addition, subtraction, multiplication, or division based on the operator passed as the second argument.

---

**Important Notes:**

- Enclose multi-word arguments in double quotes when passing them from the command line.
- All command-line arguments are treated as strings, even if they represent numbers.

By understanding how to use command-line arguments, you can create flexible and dynamic Java programs that can receive input directly from the user at runtime.

---

## End of the Chapter

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  height: 500px;
  }
  section::after {
  font-size: 20px;
  }

-->
