---
marp: false
theme: default # gaia, default, uncover,
class: middle # lead, center, middle
size: 4:3 # 4:3, 16:9, 16:10, 2.35:1, 1.85:1
header: "Institute of Technology of Cambodia"
footer: "Object-Oriented Programming with Java"
paginate: true
math: mathjax
typora-copy-images-to: ./images
---

# Chapter 9: Objects and Classes

---

## 9.1. Introduction

---

Object-oriented programming (OOP) is a programming paradigm that enables the development of large-scale software applications, including graphical user interfaces (GUIs). While Java provides fundamental features like loops, methods, and arrays, they are not sufficient for building complex systems.

OOP revolves around the concept of **objects** and **classes**. A **class** serves as a blueprint for creating **objects**, which represent real-world entities. This approach allows for code reuse, modularity, and easier maintenance.

---

This chapter introduces key concepts of OOP, such as:

- Creating and defining classes and objects
- Using constructors to initialize objects
- Differentiating between object reference variables and primitive-type variables
- Accessing and modifying object attributes using methods
- Working with Java’s built-in classes like `Date`, `Random`, and `Point2D`
- Understanding instance and static members
- Implementing encapsulation to protect data

---

## 9.2. Defining Classes for Objects

---

In object-oriented programming (OOP), a **class** defines the properties (data fields) and behaviors (methods) of objects. An **object** is an instance of a class that represents a real-world entity with three main characteristics:

1. **State (Attributes/Properties)** – Represented by data fields (e.g., a `Circle` object has a `radius`).
2. **Behavior (Methods/Actions)** – Defined by methods (e.g., a `Circle` object has a `getArea()` method).
3. **Identity** – Each object is uniquely identifiable in memory.

---

#### Key Concepts:

- **Classes as Blueprints**: A class is a template that defines how objects of the same type should behave and what data they should contain.
- **Instantiation**: Creating an object from a class using the `new` keyword.
- **Example – Circle Class**:
  - A `Circle` class can define a `radius` field and methods like `getArea()` and `getPerimeter()`.
  - A constructor initializes the object.
- **Unified Modeling Language (UML)**: UML diagrams visually represent classes, showing attributes, methods, and relationships.

---

## 9.3. Example – Defining Classes and Creating Objects

---

This section provides practical examples of defining classes and creating objects in Java.

---

#### Key Concepts:

1. **Classes and Objects**:

   - A class serves as a blueprint for creating objects.
   - Objects have **data fields** (attributes) and **methods** (behaviors).

2. **Example – `Circle` Class:**

   - Defines a `radius` field and methods like `getArea()` and `getPerimeter()`.
   - Includes **constructors** to initialize objects with or without a specified radius.

---

3. **Creating Objects:**

   - Objects are created using the `new` keyword.
   - Example:
     ```java
     Circle circle1 = new Circle(); // Creates a circle with default radius
     Circle circle2 = new Circle(25); // Creates a circle with radius 25
     ```
   - Methods are called using object references (`circle1.getArea()`).

4. **UML Class Diagram Representation:**

   - UML diagrams visually represent classes, their attributes, and methods.

---

5. **Java Compilation Process:**
   - Each class in a Java file is compiled into a separate `.class` file.

---

#### Additional Example – `TV` Class:

- Models a TV with attributes like `channel`, `volumeLevel`, and `on/off` state.
- Provides methods to turn the TV on/off, change channels, and adjust volume.
- Demonstrates how multiple objects of the same class can have different states.

This section reinforces the fundamental concepts of defining, instantiating, and using objects in Java programs.

---

## 9.4. Constructing Objects Using Constructors

---

A **constructor** is a special type of method used to create and initialize objects.

---

#### Key Characteristics of Constructors:

1. **Same Name as the Class** – A constructor must have the same name as its class.
2. **No Return Type** – Unlike regular methods, constructors do not have a return type (not even `void`).
3. **Invoked with `new` Operator** – A constructor is called automatically when an object is created.

---

#### Types of Constructors:

- **No-Argument (No-Arg) Constructor:**

  - Initializes default values for an object.
  - Example:

    ```java
    class Circle {
        double radius;

        // No-arg constructor
        Circle() {
            radius = 1.0;
        }
    }
    ```

---

- **Parameterized Constructor:**

  - Accepts arguments to initialize an object with specific values.
  - Example:

    ```java
    class Circle {
        double radius;

        // Parameterized constructor
        Circle(double newRadius) {
            radius = newRadius;
        }
    }
    ```

---

#### Default Constructor:

- If no constructor is defined, Java automatically provides a **default constructor** with an empty body.
- Example:
  ```java
  class Test {
      // Java automatically provides: Test() { }
  }
  ```

---

#### Constructor Overloading:

- A class can have multiple constructors with different parameter lists (overloading).
- Example:

  ```java
  class Circle {
      double radius;

      // No-arg constructor
      Circle() {
          radius = 1.0;
      }

      // Parameterized constructor
      Circle(double newRadius) {
          radius = newRadius;
      }
  }
  ```

---

#### Common Mistake:

- Declaring a constructor with a return type (e.g., `public void Circle()`) makes it a regular method, not a constructor.

By using constructors, Java ensures that objects are properly initialized when created.

---

#### 9.5: Accessing Objects via Reference Variables

---

In Java, objects are accessed using **reference variables**, which store the memory address of an object rather than the object itself.

---

#### Key Concepts:

---

1. **Declaring and Assigning Object References:**

   - A reference variable is declared using the class name:
     ```java
     Circle myCircle;
     ```
   - It must be assigned an object using the `new` keyword:
     ```java
     myCircle = new Circle();
     ```
   - This can also be done in a single line:
     ```java
     Circle myCircle = new Circle();
     ```

---

2. **Accessing Object Data and Methods:**

   - The **dot operator (`.`)** is used to access an object’s fields and methods.
     ```java
     myCircle.radius = 5.0;   // Accessing a data field
     double area = myCircle.getArea();  // Invoking a method
     ```

---

3. **Instance Variables and Methods:**

   - **Instance Variables** belong to specific objects and hold unique data for each object.
   - **Instance Methods** operate on an object’s data and must be called on an instance.

---

4. **Anonymous Objects:**

   - Objects that are created but not assigned to a variable:
     ```java
     System.out.println("Area is " + new Circle(5).getArea());
     ```
   - These are useful for one-time operations.

---

5. **`null` Value and NullPointerException:**

   - If an object reference variable is not assigned an object, it defaults to `null`.
   - Accessing methods or fields on `null` causes a `NullPointerException`.
     ```java
     Circle myCircle = null;
     System.out.println(myCircle.radius); // Causes an error
     ```

---

6. **Primitive vs. Reference Type Variables:**

   - **Primitive variables** store actual values (e.g., `int x = 5;`).
   - **Reference variables** store the address of an object in memory.
   - Assigning one reference variable to another does not copy the object but instead copies the reference, meaning both variables point to the same object.

---

7. **Garbage Collection:**
   - When an object is no longer referenced, Java’s garbage collector automatically reclaims its memory.
   - Explicitly setting an object reference to `null` helps mark it for garbage collection.

This section explains how objects are managed in memory, how they are accessed, and the importance of reference variables in Java programming.

---

## 9.6. Using Classes from the Java Library

---

Java provides a rich set of prebuilt classes in its **Java API (Application Programming Interface)**, which developers can use to simplify programming tasks. This section introduces commonly used Java library classes.

---

#### Key Classes Covered:

1. **`Date` Class (`java.util.Date`)**

   - Represents a specific date and time.
   - The no-arg constructor creates a `Date` object for the current date and time.
   - Example:
     ```java
     java.util.Date date = new java.util.Date();
     System.out.println(date.toString());
     ```
   - `getTime()` returns the number of milliseconds since **January 1, 1970 (Epoch time)**.
   - A `Date` object can also be created with a specific timestamp:
     ```java
     Date date = new Date(1000000000000L);
     ```

---

2. **`Random` Class (`java.util.Random`)**

   - Used to generate random numbers.
   - Example:
     ```java
     java.util.Random rand = new java.util.Random();
     int randomNumber = rand.nextInt(100); // Generates a random number between 0 and 99
     ```
   - A seed can be provided to generate the same sequence of random numbers.

---

3. **`Point2D` Class (`javafx.geometry.Point2D`)**
   - Represents a point in a 2D plane with `x` and `y` coordinates.
   - Useful for geometric calculations like distance and midpoint.
   - Example:
     ```java
     import javafx.geometry.Point2D;
     Point2D p1 = new Point2D(3, 4);
     Point2D p2 = new Point2D(6, 8);
     double distance = p1.distance(p2);
     ```
   - The `toString()` method provides a readable format for points.

---

#### **Key Takeaways:**

- Java provides built-in classes for handling common programming tasks like date/time management, random number generation, and geometric calculations.
- Using these predefined classes simplifies coding and improves efficiency.
- `Date` and `Random` are in the `java.util` package, while `Point2D` is in `javafx.geometry`.
- Java also offers `SecureRandom` (from `java.security`) for cryptographic-level randomness.

Understanding and utilizing Java's built-in classes can significantly enhance program functionality and reduce development time.

---

## 9.7. Static Variables, Constants, and Methods

---

In Java, the **`static`** keyword is used to define class-level variables and methods that are shared across all instances of a class.

---

#### **Key Concepts:**

1. **Static Variables (Class Variables):**

   - Shared among all instances of a class.
   - Declared using the `static` keyword.
   - Stored in a common memory location, rather than being unique to each object.
   - Example:

     ```java
     class Circle {
         double radius;
         static int numberOfObjects = 0; // Shared among all instances

         Circle(double newRadius) {
             radius = newRadius;
             numberOfObjects++; // Increment when a new object is created
         }
     }
     ```

---

2. **Static Methods:**

   - Can be called without creating an object of the class.
   - Cannot access instance variables or instance methods directly.
   - Typically used for utility functions or to operate on static variables.
   - Example:
     ```java
     public static int getNumberOfObjects() {
         return numberOfObjects;
     }
     ```

---

3. **Static vs. Instance Members:**

   - **Instance variables and methods** belong to individual objects.
   - **Static variables and methods** belong to the class itself.
   - **A static method cannot access non-static (instance) variables/methods directly.**

---

4. **Constants in Java:**

   - Declared as `static final` to make them shared and unchangeable.
   - Example:
     ```java
     public class MathConstants {
         public static final double PI = 3.141592653589793;
     }
     ```

---

5. **Accessing Static Members:**

   - Recommended to access static members using the class name rather than an object reference for clarity.
   - Example:
     ```java
     System.out.println(Circle.numberOfObjects); // Correct
     ```

---

6. **Common Mistakes:**
   - Attempting to access an **instance variable or method** from a **static method** (causes a compilation error).
   - Forgetting to declare a shared variable as `static`, causing it to be treated as an instance variable.

---

#### **Key Takeaways:**

- **Static members belong to the class, not instances.**
- **Use `static` when a variable or method should be shared among all objects.**
- **Static methods cannot directly access instance variables/methods.**
- **Use `static final` for constants to prevent modification.**

This section helps in understanding when to use static members and how they differ from instance members.

---

## 9.8. Visibility Modifiers

---

**Visibility modifiers** in Java control access to classes, variables, and methods, ensuring data encapsulation and security.

---

#### **Key Visibility Modifiers:**

1. **`public`**

   - Accessible from **anywhere** in the program.
   - Used for classes, methods, and variables that should be globally available.
   - Example:
     ```java
     public class Circle {
         public double radius;  // Can be accessed from any class
     }
     ```

---

2. **`private`**

- Accessible **only within the same class**.
- Prevents direct modification of data fields from outside the class (encapsulation).
- Example:
  ```java
  class Circle {
      private double radius;  // Only accessible inside the Circle class
  }
  ```

---

- To allow controlled access, **getter and setter methods** are used:
  ```java
  public double getRadius() {
      return radius;
  }
  public void setRadius(double newRadius) {
      radius = newRadius;
  }
  ```

---

1. **Default (Package-Private, No Modifier)**

   - If no modifier is specified, the member is accessible **only within the same package**.
   - Useful for restricting access to related classes within a package.
   - Example:
     ```java
     class Circle {  // Can be accessed only within the same package
         double radius;
     }
     ```

---

2. **`protected`** _(Introduced in Chapter 11)_
   - Accessible within the same package **and** by subclasses.
   - Used for inheritance scenarios.

---

#### **Key Takeaways:**

- **Use `private` for data fields** to enforce encapsulation.
- **Use `public` for methods that need to be accessed globally.**
- **Use package-private (default) for package-level access.**
- **The `protected` modifier is mainly used in inheritance (covered later).**

By controlling access with visibility modifiers, Java promotes **data protection, modularity, and maintainability** in object-oriented programs.

---

## 9.9. Data Field Encapsulation

---

**Key Concepts:**

1. **Encapsulation**: Encapsulation is a fundamental principle in object-oriented programming that involves restricting direct access to an object's data fields. Instead, access is provided through public methods, known as getters and setters.
2. **Private Data Fields**: To prevent direct modification of data fields, they should be declared as `private`. This ensures that the data can only be accessed or modified through the methods provided by the class.

---

3. **Getter and Setter Methods**:

   - **Getter (Accessor)**: A method that returns the value of a private data field. The naming convention is `getPropertyName()` or `isPropertyName()` for boolean fields.
   - **Setter (Mutator)**: A method that sets or updates the value of a private data field. The naming convention is `setPropertyName(dataType propertyValue)`.

---

4. **Benefits of Encapsulation**:

   - **Data Protection**: Prevents unauthorized or unintended modification of data.
   - **Maintainability**: Makes the class easier to maintain and modify. For example, if you need to change how a data field is stored or validated, you only need to update the getter and setter methods, not the entire codebase.
   - **Control**: Allows you to add validation or other logic when data is accessed or modified.

---

5. **Example**:
   - In the `Circle` class, the `radius` and `numberOfObjects` fields are declared as `private`. To access or modify these fields, the class provides `getRadius()`, `setRadius()`, and `getNumberOfObjects()` methods.
   - The `setRadius()` method includes validation to ensure that the radius is non-negative.

---

**Example Code:**

---

```java
public class Circle {
    private double radius = 1; // Private data field
    private static int numberOfObjects = 0; // Private static data field

    // Constructor
    public Circle() {
        numberOfObjects++;
    }

    // Getter for radius
    public double getRadius() {
        return radius;
    }

    // Setter for radius with validation
    public void setRadius(double newRadius) {
        radius = (newRadius >= 0) ? newRadius : 0;
    }

    // Getter for numberOfObjects
    public static int getNumberOfObjects() {
        return numberOfObjects;
    }

    // Method to calculate area
    public double getArea() {
        return radius * radius * Math.PI;
    }
}
```

---

**Client Program Example:**

```java
public class TestCircleWithPrivateDataFields {
    public static void main(String[] args) {
        Circle myCircle = new Circle(5.0);
        System.out.println("The area of the circle of radius " + myCircle.getRadius() + " is " + myCircle.getArea());

        // Increase radius by 10%
        myCircle.setRadius(myCircle.getRadius() * 1.1);
        System.out.println("The area of the circle of radius " + myCircle.getRadius() + " is " + myCircle.getArea());

        System.out.println("The number of objects created is " + Circle.getNumberOfObjects());
    }
}
```

---

**Key Points:**

- **Private Data Fields**: Declare data fields as `private` to restrict direct access.
- **Public Methods**: Provide public getter and setter methods to control access to the data fields.
- **Validation**: Use setters to enforce rules or validation when modifying data fields.
- **Maintainability**: Encapsulation makes classes easier to maintain and less prone to bugs.

By following these principles, you can create robust and maintainable classes that protect their internal state while providing controlled access to it.

---

## 9.10. Passing Objects to Methods

---

**Key Concepts:**

1. **Passing Objects to Methods**: When you pass an object to a method in Java, you are actually passing a reference to that object. This means that the method can modify the object's state, and these changes will be reflected outside the method.

---

2. **Pass-by-Value vs. Pass-by-Reference**:

   - **Primitive Types**: When you pass a primitive type (e.g., `int`, `double`) to a method, the actual value is passed. Changes to the parameter inside the method do not affect the original variable.
   - **Reference Types**: When you pass an object (a reference type) to a method, the reference to the object is passed. This means that changes to the object's state inside the method will affect the original object.

---

3. **Example**:

   - In the example provided, a `Circle` object is passed to the `printAreas` method. Inside the method, the radius of the `Circle` object is modified, and this change is reflected in the original object outside the method.

---

4. **Call Stack and Heap**:
   - **Call Stack**: Stores method calls and local variables.
   - **Heap**: Stores objects and their data. When an object is passed to a method, the reference to the object in the heap is passed.

---

```java
public class TestPassObject {
    public static void main(String[] args) {
        Circle myCircle = new Circle(1); // Create a Circle object with radius 1
        int n = 5;
        printAreas(myCircle, n); // Pass the Circle object and an integer to the method

        // Print the final radius and n
        System.out.println("\nRadius is " + myCircle.getRadius());
        System.out.println("n is " + n);
    }

    // Method to print areas for increasing radii
    public static void printAreas(Circle c, int times) {
        System.out.println("Radius \t\tArea");
        while (times >= 1) {
            System.out.println(c.getRadius() + "\t\t" + c.getArea());
            c.setRadius(c.getRadius() + 1); // Modify the radius
            times--;
        }
    }
}
```

---

**Output:**

```
Radius 		Area
1.0		3.141592653589793
2.0		12.566370614359172
3.0		28.274333882308138
4.0		50.26548245743669
5.0		78.53981633974483

Radius is 6.0
n is 5
```

---

**Key Points:**

- **Pass-by-Value for References**: When you pass an object to a method, the reference to the object is passed by value. This means that the method can modify the object's state, but it cannot change the reference itself (i.e., it cannot make the reference point to a different object).
- **Effect on Original Object**: Changes to the object's state inside the method are reflected in the original object outside the method.
- **Primitive vs. Reference Types**: Primitive types are passed by value, and changes inside the method do not affect the original variable. Reference types are also passed by value, but the value is a reference to the object, so changes to the object's state are reflected outside the method.

---

**Illustration of Pass-by-Value for References:**

- When `myCircle` is passed to `printAreas`, the reference to the `Circle` object is passed. Inside `printAreas`, `c` refers to the same object as `myCircle`. Therefore, modifying `c` (e.g., changing the radius) modifies the same object that `myCircle` refers to.

By understanding how objects are passed to methods, you can write methods that effectively manipulate objects and their states, while being aware of the implications of these manipulations on the original objects.

---

## 9.11. Array of Objects

---

**Key Concepts:**

1. **Array of Objects**: In Java, you can create arrays that hold objects, just like you can create arrays that hold primitive types (e.g., `int`, `double`). Each element in an array of objects is a reference to an object.

2. **Initialization**:

   - When you create an array of objects, each element is initially set to `null`. You need to explicitly create objects and assign them to the array elements.
   - Example: `Circle[] circleArray = new Circle[10];` creates an array of 10 `Circle` references, all initially `null`.

---

3. **Accessing Objects in the Array**:

   - To access an object in the array, you use the array index (e.g., `circleArray[0]`).
   - You can then call methods on the object (e.g., `circleArray[0].getArea()`).

4. **Example**:
   - The example provided demonstrates how to create an array of `Circle` objects, initialize each element with a `Circle` object, and then calculate and display the total area of all circles in the array.

---

**Example Code:**

---

```java
public class TotalArea {
    public static void main(String[] args) {
        // Declare circleArray
        Circle[] circleArray;

        // Create circleArray with random radii
        circleArray = createCircleArray();

        // Print circleArray and total areas of the circles
        printCircleArray(circleArray);
    }

    // Method to create an array of Circle objects
    public static Circle[] createCircleArray() {
        Circle[] circleArray = new Circle[5];

        for (int i = 0; i < circleArray.length; i++) {
            circleArray[i] = new Circle(Math.random() * 100);
        }

        return circleArray;
    }

    // Method to print the array of circles and their total area
    public static void printCircleArray(Circle[] circleArray) {
        System.out.printf("%-30s%-15s\n", "Radius", "Area");

        for (int i = 0; i < circleArray.length; i++) {
            System.out.printf("%-30f%-15f\n", circleArray[i].getRadius(), circleArray[i].getArea());
        }

        System.out.println("----------------------------------------");

        // Compute and display the total area
        System.out.printf("%-30s%-15f\n", "The total area of circles is", sum(circleArray));
    }

    // Method to calculate the total area of circles in the array
    public static double sum(Circle[] circleArray) {
        double sum = 0;

        for (int i = 0; i < circleArray.length; i++) {
            sum += circleArray[i].getArea();
        }

        return sum;
    }
}
```

---

**Output Example:**

```
Radius                          Area
70.577708                       15649.941866
44.152266                       6124.291736
24.867853                       1942.792644
5.680718                        101.380949
36.734246                       4239.280350
----------------------------------------
The total area of circles is     28056.687544
```

---

**Key Points:**

- **Array of References**: An array of objects is essentially an array of references. Each element in the array is a reference to an object, and initially, these references are set to `null`.
- **Initialization**: You need to create objects and assign them to the array elements. For example, `circleArray[i] = new Circle();`.
- **Accessing Objects**: You can access and manipulate objects in the array using their indices, e.g., `circleArray[0].getArea()`.
- **Passing Arrays to Methods**: You can pass arrays of objects to methods, just like you pass arrays of primitive types. The method can then manipulate the objects in the array.

---

**Illustration of Array of Objects:**

- When you create an array of objects, the array itself is stored in memory, and each element of the array holds a reference to an object. For example:
  ```
  circleArray -> [ref0, ref1, ref2, ref3, ref4]
                  |     |     |     |     |
                  v     v     v     v     v
                Circle Circle Circle Circle Circle
  ```
  - `circleArray[0]` refers to the first `Circle` object, `circleArray[1]` refers to the second `Circle` object, and so on.

By understanding how to work with arrays of objects, you can manage collections of objects efficiently and perform operations on multiple objects at once.

---

## 9.12. Immutable Objects and Classes

---

**Key Concepts:**

1. **Immutable Objects**: An immutable object is an object whose state cannot be modified after it is created. Once an immutable object is constructed, its data fields cannot be changed.

---

2. **Immutable Classes**: A class is considered immutable if all of its instances are immutable. To create an immutable class, you must ensure that:

   - All data fields are declared `private`.
   - There are no public setter methods (mutators) that can modify the data fields.
   - No methods in the class allow the modification of the internal state of the object.
   - If the class has mutable fields (e.g., objects or arrays), ensure that no references to these fields are exposed. Return copies of mutable fields instead of the actual references.

---

3. **Benefits of Immutable Objects**:

   - **Thread Safety**: Immutable objects are inherently thread-safe because their state cannot change after construction.
   - **Simplicity**: Immutable objects are easier to reason about since their state is constant.
   - **Security**: Immutable objects are safer to use in contexts where the object's state should not be altered, such as in caching or as keys in hash maps.

---

4. **Example**:
   - The `String` class in Java is an example of an immutable class. Once a `String` object is created, its content cannot be changed.
   - If you remove the setter method (`setRadius`) from the `Circle` class, the class becomes immutable because the `radius` field cannot be modified after the object is created.

---

**Example Code:**

---

```java
public class Circle {
    private double radius; // Private data field

    // Constructor
    public Circle(double radius) {
        this.radius = radius;
    }

    // Getter for radius (no setter provided)
    public double getRadius() {
        return radius;
    }

    // Method to calculate area
    public double getArea() {
        return radius * radius * Math.PI;
    }
}
```

---

**Key Points:**

- **Private Data Fields**: All data fields must be declared `private` to prevent direct access.
- **No Setters**: Do not provide public setter methods that can modify the data fields.
- **Mutable Fields**: If the class contains mutable fields (e.g., arrays or other objects), ensure that no references to these fields are exposed. Return copies of mutable fields instead of the actual references.
- **Final Fields**: While not strictly necessary, declaring data fields as `final` can reinforce immutability by ensuring that the fields cannot be reassigned after construction.

---

**Example of a Mutable Field Issue:**

---

```java
public class Student {
    private int id;
    private String name;
    private java.util.Date dateCreated;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
        this.dateCreated = new java.util.Date();
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public java.util.Date getDateCreated() {
        return dateCreated; // This exposes a reference to a mutable object
    }
}
```

---

In the above example, the `getDateCreated()` method returns a reference to the `dateCreated` field, which is mutable. This allows the caller to modify the `Date` object, breaking the immutability of the `Student` class.

---

**Solution: Return a Copy of the Mutable Field:**

```java
public java.util.Date getDateCreated() {
    return new java.util.Date(dateCreated.getTime()); // Return a copy of the Date object
}
```

---

**Key Points for Immutable Classes:**

- **No Modification**: Ensure that no method allows modification of the object's state.
- **Defensive Copies**: When returning mutable fields, return a copy of the field instead of the actual reference.
- **Final Fields**: Use `final` to prevent reassignment of fields after construction.

By following these principles, you can create immutable classes that provide the benefits of thread safety, simplicity, and security. Immutable objects are particularly useful in concurrent programming and in scenarios where the object's state should remain constant throughout its lifetime.

---

## 9.13. The Scope of Variables

---

**Key Concepts:**

1. **Scope of Variables**: The scope of a variable defines where in the program the variable can be accessed. In Java, the scope of a variable depends on where it is declared.

---

2. **Types of Variables**:

   - **Instance Variables**: Declared inside a class but outside any method. They are accessible from all methods, constructors, and blocks in the class. Their scope is the entire class.
   - **Static Variables**: Similar to instance variables but declared with the `static` keyword. They are shared among all instances of the class and have the same scope as instance variables.
   - **Local Variables**: Declared inside a method, constructor, or block. They are only accessible within the method, constructor, or block where they are declared. Their scope is limited to the block in which they are declared.

---

3. **Scope Rules**:

   - **Class-Level Variables (Instance and Static)**: Can be accessed from anywhere within the class, regardless of where they are declared. However, if a local variable with the same name exists in a method, the local variable will take precedence (this is called variable shadowing).
   - **Local Variables**: Only accessible within the block they are declared in. They cannot be accessed outside that block.

---

4. **Variable Shadowing**: If a local variable has the same name as an instance or static variable, the local variable will "shadow" the class-level variable within the scope of the local variable. To access the class-level variable, you can use the `this` keyword for instance variables or the class name for static variables.

---

**Example Code:**

```java
public class F {
    private int x = 0; // Instance variable
    private int y = 0; // Instance variable

    public F() {
        // Constructor
    }

    public void p() {
        int x = 1; // Local variable (shadows the instance variable x)
        System.out.println("x = " + x); // Refers to the local variable x
        System.out.println("y = " + y); // Refers to the instance variable y
    }
}
```

**Output:**

```
x = 1
y = 0
```

---

**Explanation:**

- The local variable `x` in the method `p()` shadows the instance variable `x`. Therefore, `System.out.println("x = " + x);` prints the value of the local variable `x`, which is `1`.
- The instance variable `y` is not shadowed, so `System.out.println("y = " + y);` prints the value of the instance variable `y`, which is `0`.

---

**Key Points:**

- **Instance and Static Variables**: Have class-level scope and can be accessed from anywhere within the class.
- **Local Variables**: Have block-level scope and can only be accessed within the block they are declared in.
- **Variable Shadowing**: When a local variable has the same name as an instance or static variable, the local variable takes precedence within its scope. To access the class-level variable, use `this` for instance variables or the class name for static variables.
- **Order of Declaration**: Class members (variables and methods) can be declared in any order within the class, except when a data field is initialized based on another data field. In such cases, the other data field must be declared first.

---

**Example of Variable Shadowing with `this`:**

```java
public class Circle {
    private double radius; // Instance variable

    public Circle(double radius) {
        this.radius = radius; // Use 'this' to refer to the instance variable
    }

    public void setRadius(double radius) {
        this.radius = radius; // Use 'this' to refer to the instance variable
    }
}
```

---

**Key Points for Variable Scope:**

- **Class-Level Variables**: Accessible throughout the class.
- **Local Variables**: Limited to the block they are declared in.
- **Shadowing**: Local variables can shadow class-level variables. Use `this` to access the class-level variable.
- **Order of Declaration**: Class members can be declared in any order, except when one field depends on another.

---

By understanding the scope of variables, you can avoid common pitfalls such as variable shadowing and ensure that your variables are accessible where they are needed. This helps in writing clear and maintainable code.

---

## 9.14. The `this` Reference

---

**Key Concepts:**

1. **The `this` Keyword**: The `this` keyword in Java refers to the current instance of the class. It is used to:

   - Access instance variables and methods of the current object.
   - Differentiate between instance variables and parameters or local variables with the same name.
   - Invoke another constructor of the same class (constructor chaining).

---

2. **Using `this` to Access Instance Members**:

   - When a method parameter or local variable has the same name as an instance variable, the parameter or local variable shadows the instance variable. The `this` keyword can be used to explicitly refer to the instance variable.
   - Example: `this.radius = radius;` in a constructor or setter method.

---

3. **Using `this` to Invoke Another Constructor**:

   - The `this` keyword can be used to call one constructor from another constructor in the same class. This is known as constructor chaining.
   - The call to another constructor must be the first statement in the constructor.
   - Example: `this(1.0);` in a no-arg constructor to call a parameterized constructor.

---

4. **Example**:
   - The example provided demonstrates how to use the `this` keyword to reference instance variables and to invoke another constructor.

---

**Example Code:**

---

```java
public class Circle {
    private double radius;

    // No-arg constructor
    public Circle() {
        this(1.0); // Invoke the parameterized constructor with a default radius of 1.0
    }

    // Parameterized constructor
    public Circle(double radius) {
        this.radius = radius; // Use 'this' to refer to the instance variable
    }

    // Setter method
    public void setRadius(double radius) {
        this.radius = radius; // Use 'this' to refer to the instance variable
    }

    // Getter method
    public double getRadius() {
        return radius;
    }

    // Method to calculate area
    public double getArea() {
        return radius * radius * Math.PI;
    }
}
```

**Key Points:**

- **Accessing Instance Variables**: Use `this` to refer to instance variables when they are shadowed by method parameters or local variables.
- **Constructor Chaining**: Use `this(arg-list)` to call another constructor in the same class. This must be the first statement in the constructor.
- **Readability**: Using `this` can improve code readability by making it clear when you are referring to instance variables.

---

**Example of Constructor Chaining:**

```java
public class Circle {
    private double radius;

    // No-arg constructor
    public Circle() {
        this(1.0); // Calls the parameterized constructor with a default radius of 1.0
    }

    // Parameterized constructor
    public Circle(double radius) {
        this.radius = radius; // Use 'this' to refer to the instance variable
    }
}
```

---

**Key Points for Using `this`:**

- **Instance Variable Access**: Use `this` to access instance variables when they are shadowed by local variables or parameters.
- **Constructor Chaining**: Use `this(arg-list)` to call another constructor in the same class. This must be the first statement in the constructor.
- **Readability and Clarity**: Using `this` can make the code more readable and clarify the intent, especially when distinguishing between instance variables and local variables.

---

**Example of Shadowing and Using `this`:**

```java
public class Circle {
    private double radius;

    public Circle(double radius) {
        this.radius = radius; // 'this.radius' refers to the instance variable, 'radius' refers to the parameter
    }

    public void setRadius(double radius) {
        this.radius = radius; // 'this.radius' refers to the instance variable, 'radius' refers to the parameter
    }
}
```

---

**Key Points for the `this` Reference:**

- **Instance Members**: Use `this` to access instance variables and methods.
- **Constructor Chaining**: Use `this(arg-list)` to invoke another constructor in the same class.
- **Avoiding Shadowing**: Use `this` to avoid confusion when local variables or parameters shadow instance variables.

---

By understanding and using the `this` keyword effectively, you can write clearer and more maintainable code, especially in classes with multiple constructors or methods where variable shadowing might occur.

<!-- style: |

  section {
  font-family: Nokora;
  }
  h1 {
  color: black;
  font-size: 50px;
  text-align: center;
  }
  h2 {
  font-size: 40px;
  text-align: center;
  }
  h3 {
  font-size: 30px;
  position: absolute;
  top: 60px;
  }
  h4 {
  font-size: 28px;
  }
  h5 {
  font-size: 28px;
  }
  h6 {
  font-size: 26px;
  }
  p {
  font-size: 26px;
  }
  li {
  font-size: 26px;
  }
  table {
  margin: auto;
  font-size: 20px;
  }
  img {
  display: block;
  margin: 0 auto;
  height: 500px;
  }
  section::after {
  font-size: 20px;
  }

-->
